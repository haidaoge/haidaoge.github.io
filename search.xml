<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go字符串相关]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FGo%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[1.字符串截取和分割在Golang里面，如果一个空字符串通过strings包的Split函数进行切割，其结果和js是类似的，但是在beego里却不能再使用string[:]字符串截取方法如：1234workpoints := &quot;[-91.09171271324158,14.189695469829985],[-91.09187934547663,14.18840015515362],[-91.0902341455221,14.188149217552196]&quot;str := strings.Split(workpoints, &quot;],&quot;)[0]firstpoint := str[1:len(str)] // error: slice bounds out of range 在golang里是可以的 123456789for i := 0; i &lt; len(str); i++ &#123; fmt.Println(str[i][1:len(str[i])])&#125;// -91.09171271324158// 4.189695469829985]// -91.09187934547663// 4.18840015515362]// -91.0902341455221// 4.188149217552196] 如果想去掉某些字符可以用 strings包的Replace() 方法 12str := strings.Split(workpoints, &quot;],&quot;)[0]fristpoint := strings.Replace(str, &quot;[&quot;, &quot;&quot;, -1) 2.字符串拼接实现方法 直接使用运算符1234567func BenchmarkAddStringWithOperator(b *testing.B) &#123; hello := &quot;hello&quot; world := &quot;world&quot; for i := 0; i &lt; b.N; i++ &#123; _ = hello + &quot;,&quot; + world &#125;&#125; golang 里面的字符串都是不可变的，每次运算都会产生一个新的字符串，所以会产生很多临时的无用的字符串，不仅没有用，还会给 gc 带来额外的负担，所以性能比较差 fmt.Sprintf()1234567func BenchmarkAddStringWithSprintf(b *testing.B) &#123; hello := &quot;hello&quot; world := &quot;world&quot; for i := 0; i &lt; b.N; i++ &#123; _ = fmt.Sprintf(&quot;%s,%s&quot;, hello, world) &#125;&#125; 内部使用 []byte 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很多额外的判断，还用到了 interface，所以性能也不是很好 strings.Join() 1234567func BenchmarkAddStringWithJoin(b *testing.B) &#123; hello := &quot;hello&quot; world := &quot;world&quot; for i := 0; i &lt; b.N; i++ &#123; _ = strings.Join([]string&#123;hello, world&#125;, &quot;,&quot;) &#125;&#125; join会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符串填入，在已有一个数组的情况下，这种效率会很高，但是本来没有，去构造这个数据的代价也不小 buffer.WriteString() 1234567891011func BenchmarkAddStringWithBuffer(b *testing.B) &#123; hello := &quot;hello&quot; world := &quot;world&quot; for i := 0; i &lt; 1000; i++ &#123; var buffer bytes.Buffer buffer.WriteString(hello) buffer.WriteString(&quot;,&quot;) buffer.WriteString(world) _ = buffer.String() &#125;&#125; 这个比较理想，可以当成可变字符使用，对内存的增长也有优化，如果能预估字符串的长度，还可以用 buffer.Grow() 接口来设置 capacity 12345测试结果BenchmarkAddStringWithOperator-8 50000000 30.3 ns/opBenchmarkAddStringWithSprintf-8 5000000 261 ns/opBenchmarkAddStringWithJoin-8 30000000 58.7 ns/opBenchmarkAddStringWithBuffer-8 2000000000 0.00 ns/op 这个是在我的自己 Mac 上面跑的结果，go 版本 go version go1.8 darwin/amd64，这个结果仅供参考，还是要以实际生产环境的值为准，代码在：https://github.com/hatlonely/… 主要结论 在已有字符串数组的场合，使用 strings.Join() 能有比较好的性能 在一些性能要求较高的场合，尽量使用 buffer.WriteString() 以获得更好的性能 性能要求不太高的场合，直接使用运算符，代码更简短清晰，能获得比较好的可读性 如果需要拼接的不仅仅是字符串，还有数字之类的其他需求的话，可以考虑 fmt.Sprintf]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go函数执行顺序]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FGo%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[go的执行顺序1234567891011121314151617181920212223242526272829package mainimport ( &quot;errors&quot; &quot;fmt&quot;)func main() &#123; println(&quot;===========================&quot;) r, _ := div(6, 3) fmt.Println(r)&#125;func div(x, y int) (int, error) &#123; defer println(&quot;dispose...&quot;) if y == 0 &#123; return 0, errors.New(&quot;division by zero&quot;) &#125; println(&quot;gogo&quot;) return x / y, nil&#125;/*===========================gogodispose...2*/ 上述执行结果表明 go的执行顺序 从==主程== 到==线程==，线程中的defer不会影响到主程，”dispose…”在”gogo”之后再2之前就可以表明]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go实践之路二---类型转换]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FGo%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%E4%BA%8C---%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[最近在学习golang开发碰到问题最多的就是类型转化最常用的转换是interface与int，string的转化，方法简单粗暴12interface.(string) //type interface &#123;&#125; to stringinterface.(int) //type interface &#123;&#125; to int interface转int64123456baseInfo := map[string]interface&#123;&#125;&#123; &quot;account&quot;: &quot;hnzdzn&quot;, &quot;password&quot;: &quot;hnzdzn123&quot;, &quot;terminalNumber&quot;: &quot;380000&quot;, &quot;workid&quot;: 1533372762, &quot;droneid&quot;: &quot;005300343436511436393438&quot;&#125; 如上所示workid是一串数字，本以为可以像js一样优雅的使用。。。。谁知它报错了==cannot use baseInfo[“workid”] (type interface {}) as type int64 in argument==，明明就是数字非要分类型，数字就是数字嘛还分什么interface类型数字，int，int32, int64… 吐槽完继续改 interface 好像没有直接转成int64的方法，那我就先转成int，在通过int64()方法转换 1workid := int64(baseInfo[&quot;workid&quot;].(int)) float64转string 在网上查了查，float64转string好像就这种方法 12345var lng float64lng = strconv.FormatFloat(lng, &apos;E&apos;, -1, 64)fmt.Printf(&quot;type of lng is: %T &quot;, lng) // string 看一个需求：将一个interface类型保留小数点后六位，然后再转为string类型 12345678910111213lng, _ := strconv.ParseFloat(lnglat[0], 64)lat, _ := strconv.ParseFloat(lnglat[1], 64)lng, _ = strconv.ParseFloat(fmt.Sprintf(&quot;%.6f&quot;, lng), 64)lat, _ = strconv.ParseFloat(fmt.Sprintf(&quot;%.6f&quot;, lat), 64)list[&quot;longitude&quot;] = strconv.FormatFloat(lng, &apos;E&apos;, -1, 64)list[&quot;latitude&quot;] = strconv.FormatFloat(lat, &apos;E&apos;, -1, 64)// &apos;b&apos; (-ddddp±ddd，二进制指数)// &apos;e&apos; (-d.dddde±dd，十进制指数)// &apos;E&apos; (-d.ddddE±dd，十进制指数)// &apos;f&apos; (-ddd.dddd，没有指数)// &apos;g&apos; (&apos;e&apos;:大指数，&apos;f&apos;:其它情况)// &apos;G&apos; (&apos;E&apos;:大指数，&apos;f&apos;:其它情况) string转float123456s := &quot;3.1415926&quot;F, _ := strconv.ParseFloat(s, 64)fmt.Printf(&quot;F: %v type: %T\n&quot;, F, F) // F: 3.1415926 type: float64f, _ := strconv.ParseFloat(s, 32)fmt.Printf(&quot;f: %v type: %T&quot;, f, f) // f: 3.141592502593994 type: float64 string转int123456s := &quot;123&quot;i, _ := strconv.Atoi(s)fmt.Printf(&quot;i: %T\n&quot;, i) // i: int ``` ### int转string i := 123s := strconv.Itoa(i)fmt.Printf(“s: %v type: %T”, s, s) // s: 123 type: string 12### int64转string i := int64(123)s := strconv.FormatInt(i, 10) fmt.Printf(“s: %v type: %T”, s, s) // s: 123 type: string 12### string转int64 s := “123”i, _ := strconv.ParseInt(s, 10, 64)fmt.Printf(“i: %v type: %T”, i, i) // i: 123 type: int64 12### map[string]interface&#123;&#125; 转map[string]string var result map[string]interface{}list := make(map[string]string)for k, v := range result { list[k] = v.(string)}]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习笔记三---高级]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FGo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89---%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Go 程Go 程（goroutine）是由 Go 运行时管理的轻量级线程。go f(x, y, z)会启动一个新的 Go 程并执行f(x, y, z)f, x, y 和 z 的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中。Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。sync 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法（见下一页）。 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot; &quot;time&quot;)func say(s string) &#123; for i := 0; i &lt; 5; i++ &#123; time.Sleep(100 * time.Millisecond) fmt.Println(s) &#125;&#125;func main() &#123; go say(&quot;world&quot;) say(&quot;hello&quot;)&#125;/**worldhellohelloworldworldhellohelloworldworldhello*/ 信道信道是带有类型的管道，你可以通过它用信道操作符 &lt;- 来发送或者接收值。 ch &lt;- v // 将 v 发送至信道 ch。 v := &lt;-ch // 从 ch 接收值并赋予 v。 （“箭头”就是数据流的方向。） 和映射与切片一样，信道在使用前必须创建： ch := make(chan int) 默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。 以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func sum(s []int, c chan int) &#123; sum := 0 for _, v := range s &#123; sum += v &#125; c &lt;- sum // 将和送入 c&#125;func main() &#123; s := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // 从 c 中接收 fmt.Println(x, y, x+y)&#125; ###带缓冲的信道信道可以是 带缓冲的。将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道： ch := make(chan int, 100)仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。 修改示例填满缓冲区，然后看看会发生什么。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; ch := make(chan int, 1) ch &lt;- 1 ch &lt;- 2 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)&#125;// 1// 2 range 和 close发送者可通过 close 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完 v, ok := &lt;-ch之后 ok 会被设置为 false。 循环 for i := range c 会不断从信道接收值，直到它被关闭。 注意： 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。 还要注意： 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有值需要发送的时候才有必要关闭，例如终止一个 range 循环 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;fmt&quot;)func fibonacci(n int, c chan int) &#123; x, y := 0, 1 for i := 0; i &lt; n; i++ &#123; c &lt;- x x, y = y, x+y &#125; close(c)&#125;func main() &#123; c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c &#123; fmt.Println(i) &#125;&#125;/**0112358132134*/ select 语句select 语句使一个 Go 程可以等待多个通信操作。 select 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport &quot;fmt&quot;func fibonacci(c, quit chan int) &#123; x, y := 0, 1 for &#123; select &#123; case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println(&quot;quit&quot;) return &#125; &#125;&#125;func main() &#123; c := make(chan int) quit := make(chan int) go func() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(&lt;-c) &#125; quit &lt;- 0 &#125;() fibonacci(c, quit)&#125;/*0112358132134quit*/ ==来看个有意思的东西== 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport &quot;fmt&quot;func fibonacci(c, quit chan int) &#123; x, y := 0, 1 i := 0 for &#123; i++ fmt.Printf(&quot;%v start\n&quot;, i) select &#123; case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println(&quot;quit&quot;) return &#125; fmt.Printf(&quot;%v end\n&quot;, i) &#125;&#125;func main() &#123; c := make(chan int) quit := make(chan int) go func() &#123; fmt.Println(&quot;go func&quot;) for i := 0; i &lt; 10; i++ &#123; fmt.Println(&lt;-c) &#125; quit &lt;- 0 fmt.Println(&quot;go func end&quot;) &#125;() go func() &#123; println(&quot;go test&quot;) &#125;() fmt.Println(&quot;go main&quot;) fibonacci(c, quit)&#125; 练习：等价二叉查找树 实现 Walk 函数。 测试 Walk 函数。 函数 tree.New(k) 用于构造一个随机结构的已排序二叉查找树，它保存了值 k, 2k, 3k, …, 10k。 创建一个新的信道 ch 并且对其进行步进： go Walk(tree.New(1), ch)然后从信道中读取并打印 10 个值。应当是数字 1, 2, 3, …, 10。 用 Walk 实现 Same 函数来检测 t1 和 t2 是否存储了相同的值。 测试 Same 函数。 Same(tree.New(1), tree.New(1)) 应当返回 true，而 Same(tree.New(1), tree.New(2)) 应当返回 false。 Tree 的文档可在这里找到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( &quot;fmt&quot; &quot;golang.org/x/tour/tree&quot;)// 发送value，结束后关闭channelfunc Walk(t *tree.Tree, ch chan int) &#123; sendValue(t, ch) close(ch)&#125;// 递归向channel传值func sendValue(t *tree.Tree, ch chan int) &#123; if t != nil &#123; sendValue(t.Left, ch) ch &lt;- t.Value sendValue(t.Right, ch) &#125;&#125;// 使用写好的Walk函数来确定两个tree对象 是否一样 原理还是判断value值func Same(t1, t2 *tree.Tree) bool &#123; ch1 := make(chan int) ch2 := make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for i := range ch1 &#123; // ch1 关闭后 for循环自动跳出 if i != &lt;-ch2 &#123; return false &#125; &#125; return true&#125;func main() &#123; // 打印 tree.New(1)的值 var ch = make(chan int) go Walk(tree.New(1), ch) for v := range ch &#123; fmt.Println(v) &#125; // 比较两个tree的value值是否相等 fmt.Println(Same(tree.New(1), tree.New(1))) fmt.Println(Same(tree.New(1), tree.New(2)))&#125;/**12345678910truefalse*/ 练习：Web 爬虫在这个练习中，我们将会使用 Go 的并发特性来并行化一个 Web 爬虫。 修改 Crawl 函数来并行地抓取 URL，并且保证不重复。 提示：你可以用一个 map 来缓存已经获取的 URL，但是要注意 map 本身并不是并发安全的！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package mainimport ( &quot;fmt&quot;)type Fetcher interface &#123; // Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。 Fetch(url string) (body string, urls []string, err error)&#125;// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。func Crawl(url string, depth int, fetcher Fetcher) &#123; // TODO: 并行的抓取 URL。 // TODO: 不重复抓取页面。 // 下面并没有实现上面两种情况： if depth &lt;= 0 &#123; return &#125; body, urls, err := fetcher.Fetch(url) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(&quot;found: %s %q\n&quot;, url, body) for _, u := range urls &#123; Crawl(u, depth-1, fetcher) &#125; return&#125;func main() &#123; Crawl(&quot;https://golang.org/&quot;, 4, fetcher)&#125;// fakeFetcher 是返回若干结果的 Fetcher。type fakeFetcher map[string]*fakeResulttype fakeResult struct &#123; body string urls []string&#125;func (f fakeFetcher) Fetch(url string) (string, []string, error) &#123; if res, ok := f[url]; ok &#123; return res.body, res.urls, nil &#125; return &quot;&quot;, nil, fmt.Errorf(&quot;not found: %s&quot;, url)&#125;// fetcher 是填充后的 fakeFetcher。var fetcher = fakeFetcher&#123; &quot;https://golang.org/&quot;: &amp;fakeResult&#123; &quot;The Go Programming Language&quot;, []string&#123; &quot;https://golang.org/pkg/&quot;, &quot;https://golang.org/cmd/&quot;, &#125;, &#125;, &quot;https://golang.org/pkg/&quot;: &amp;fakeResult&#123; &quot;Packages&quot;, []string&#123; &quot;https://golang.org/&quot;, &quot;https://golang.org/cmd/&quot;, &quot;https://golang.org/pkg/fmt/&quot;, &quot;https://golang.org/pkg/os/&quot;, &#125;, &#125;, &quot;https://golang.org/pkg/fmt/&quot;: &amp;fakeResult&#123; &quot;Package fmt&quot;, []string&#123; &quot;https://golang.org/&quot;, &quot;https://golang.org/pkg/&quot;, &#125;, &#125;, &quot;https://golang.org/pkg/os/&quot;: &amp;fakeResult&#123; &quot;Package os&quot;, []string&#123; &quot;https://golang.org/&quot;, &quot;https://golang.org/pkg/&quot;, &#125;, &#125;,&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习笔记二---进阶]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FGo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C---%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[方法和接口方法Go 没有类。不过你可以为结构体类型定义方法。方法就是一类带特殊的 接收者 参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。在此例中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者。123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs())&#125;/** 5*/ 方法即函数记住：方法只是个带接收者参数的函数。 现在这个 Abs 的写法就是个正常的函数，功能并没有什么变化。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func Abs(v Vertex) float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(Abs(v))&#125;//5 非结构体类型你也可以为非结构体类型声明方法。 在此例中，我们看到了一个带 Abs 方法的数值类型 MyFloat。 你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。 （译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。） 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math&quot;)type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;func main() &#123; f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs())&#125;//1.4142135623730951 指针接收者你可以为指针接收者声明方法。 这意味着对于某类型 T，接收者的类型可以用 *T 的文法。（此外，T 不能是像 *int 这样的指针。） 例如，这里为 *Vertex 定义了 Scale 方法。 指针接收者的方法可以修改接收者指向的值（就像 Scale 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。 试着移除第 16 行 Scale 函数声明中的 *，观察此程序的行为如何变化。 若使用值接收者，那么 Scale 方法会对原始 Vertex 值的副本进行操作。（对于函数的其它参数也是如此。）Scale 方法必须用指针接受者来更改 main 函数中声明的 Vertex 的值。 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale(f float64) float64 &#123; v.X = v.X * f v.Y = v.Y * f return v.X + v.Y&#125;func main() &#123; v := Vertex&#123;3, 4&#125; m := v.Scale(10) fmt.Println(v.Abs(),m)&#125;// 50, 70 去掉* 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v Vertex) Scale(f float64) float64 &#123; v.X = v.X * f v.Y = v.Y * f return v.X + v.Y&#125;func main() &#123; v := Vertex&#123;3, 4&#125; m := v.Scale(10) fmt.Println(v.Abs(),m)&#125;// 5, 70 综上所述，指针接收者类似js中object的方法，值接收者类似js中的函数，方法在于可以改变object中的属性值，函数不能修改object中属性值 方法与指针重定向比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针： var v VertexScaleFunc(v, 5) // 编译错误！ScaleFunc(&amp;v, 5) // OK而以指针为接收者的方法被调用时，接收者既能为值又能为指针： var v Vertexv.Scale(5) // OKp := &amp;vp.Scale(10) // OK对于语句 v.Scale(5)，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5)。 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func ScaleFunc(v *Vertex, f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(2) ScaleFunc(&amp;v, 10) p := &amp;Vertex&#123;4, 3&#125; p.Scale(3) ScaleFunc(p, 8) fmt.Println(v, p) // &#123;60 80&#125; &amp;&#123;96 72&#125; fmt.Println(v, *p) // &#123;60 80&#125; &#123;96 72&#125;&#125; 同样的事情也发生在相反的方向。 接受一个值作为参数的函数必须接受一个指定类型的值： 123var v Vertexfmt.Println(AbsFunc(v)) // OKfmt.Println(AbsFunc(&amp;v)) // 编译错误！ 而以值为接收者的方法被调用时，接收者既能为值又能为指针： 1234var v Vertexfmt.Println(v.Abs()) // OKp := &amp;vfmt.Println(p.Abs()) // OK 这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs()。 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func AbsFunc(v Vertex) float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs()) fmt.Println(AbsFunc(v)) p := &amp;Vertex&#123;4, 3&#125; fmt.Println(p.Abs()) fmt.Println(AbsFunc(*p))&#125;/* 5 5 5 5 */ 注意 p := &amp;Vertex{4, 3} 依旧是构造一个Vertex结构，不是对底层构造的引用，但是有个好处就是，用这种方式初始化的结构体，执行其方法时 选择值或指针作为接收者使用指针接收者的原因有二： 首先，方法能够修改其接收者指向的值。 其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。 在本例中，Scale 和 Abs 接收者的类型为 *Vertex，即便 Abs 并不需要修改其接收者。 通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。（我们会在接下来几页中明白为什么。） 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := &amp;Vertex&#123;3, 4&#125; fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs()) v.Scale(5) fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())&#125;// Before scaling: &amp;&#123;X:3 Y:4&#125;, Abs: 5// After scaling: &amp;&#123;X:15 Y:20&#125;, Abs: 25 接口接口类型 是由一组方法签名定义的集合。 接口类型的变量可以保存任何实现了这些方法的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Abser interface &#123; Abs() float64&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat 实现了 Abser a = &amp;v // a *Vertex 实现了 Abser // 下面一行，v 是一个 Vertex（而不是 *Vertex） // 所以没有实现 Abser。 //a = v fmt.Println(a.Abs()) // 5&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125; 接口与隐式实现类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。 隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。 因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。 123456789101112131415161718192021package mainimport &quot;fmt&quot;type I interface &#123; M()&#125;type T struct &#123; S string&#125;// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。func (t T) M() &#123; fmt.Println(t.S)&#125;func main() &#123; var i I = T&#123;&quot;hello&quot;&#125; i.M() // hello&#125; 接口值在内部，接口值可以看做包含值和具体类型的元组： (value, type)接口值保存了一个具体底层类型的具体值。 接口值调用方法时会执行其底层类型的同名方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;fmt&quot; &quot;math&quot;)type I interface &#123; M()&#125;type T struct &#123; S string&#125;func (t *T) M() &#123; fmt.Println(t.S)&#125;type F float64func (f F) M() &#123; fmt.Println(f)&#125;func main() &#123; var i I i = &amp;T&#123;&quot;Hello&quot;&#125; describe(i) i.M() i = F(math.Pi) describe(i) i.M() /*(&amp;&#123;Hello&#125;, *main.T) Hello (3.141592653589793, main.F) 3.141592653589793*/&#125;func describe(i I) &#123; fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)&#125; 空接口指定了零个方法的接口值被称为 空接口： interface{}空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。） 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; var i interface&#123;&#125; describe(i) i = 42 describe(i) i = &quot;hello&quot; describe(i)&#125;func describe(i interface&#123;&#125;) &#123; fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)&#125;/*(&lt;nil&gt;, &lt;nil&gt;)(42, int)(hello, string)*/ 类型断言 一般指interface{}类型，形如：t := i.(T) 常见于 s, _ := i.(string), i, _ := i.(int) 该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。 若 i 并未保存 T 类型的值，该语句就会触发一个恐慌。 为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。 t, ok := i.(T) 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。 否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌。 请注意这种语法和读取一个映射时的相同之处。 123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main() &#123; var i interface&#123;&#125; = &quot;hello&quot; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // panic fmt.Println(f)&#125;/**hellohello true0 falsepanic: interface conversion: interface &#123;&#125; is string, not float64goroutine 1 [running]:main.main() /tmp/sandbox042281205/main.go:17 +0x220*/ 类型选择类型选择 是一种按顺序从几个类型断言中选择分支的结构。 类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func do(i interface&#123;&#125;) &#123; switch v := i.(type) &#123; case int: fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2) case string: fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v)) default: fmt.Printf(&quot;I don&apos;t know about type %T!\n&quot;, v) &#125;&#125;func main() &#123; do(21) do(&quot;hello&quot;) do(true)&#125;/**Twice 21 is 42&quot;hello&quot; is 5 bytes longI don&apos;t know about type bool!*/ Stringerfmt 包中定义的 Stringer 是最普遍的接口之一。 type Stringer interface { String() string}Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。 123456789101112131415161718192021package mainimport &quot;fmt&quot;type Person struct &#123; Name string Age int&#125;func (p Person) String() string &#123; return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)&#125;func main() &#123; a := Person&#123;&quot;Arthur Dent&quot;, 42&#125; z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125; fmt.Println(a, z)&#125;// Arthur Dent (42 years) Zaphod Beeblebrox (9001 years) 去掉 func (p Person) String() string 方法 1234567891011121314151617package mainimport &quot;fmt&quot;type Person struct &#123; Name string Age int&#125;func main() &#123; a := Person&#123;&quot;Arthur Dent&quot;, 42&#125; z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125; fmt.Println(a, z)&#125;// &#123;Arthur Dent 42&#125; &#123;Zaphod Beeblebrox 9001 练习：Stringer通过让 IPAddr 类型实现 fmt.Stringer 来打印点号分隔的地址。 例如，IPAddr{1, 2, 3, 4} 应当打印为 “1.2.3.4”。 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;type IPAddr [4]byte// TODO: Add a &quot;String() string&quot; method to IPAddr.func (ip IPAddr) String() string &#123; return fmt.Sprintf(&quot;%v.%v.%v.%v&quot;, ip[0], ip[1], ip[2], ip[3])&#125;func main() &#123; hosts := map[string]IPAddr&#123; &quot;loopback&quot;: &#123;127, 0, 0, 1&#125;, &quot;googleDNS&quot;: &#123;8, 8, 8, 8&#125;, &#125; for name, ip := range hosts &#123; fmt.Printf(&quot;%v: %v\n&quot;, name, ip) &#125;&#125;/*没有fmt.Stringer : loopback: [127 0 0 1]googleDNS: [8 8 8 8]加上 fmt.Stringer:loopback: 127.0.0.1googleDNS: 8.8.8.8*/ 练习：错误从之前的练习中复制 Sqrt 函数，修改它使其返回 error 值。 Sqrt 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。 创建一个新的类型 type ErrNegativeSqrt float64并为其实现 func (e ErrNegativeSqrt) Error() string方法使其拥有 error 值，通过 ErrNegativeSqrt(-2).Error() 调用该方法应返回 “cannot Sqrt negative number: -2”。 注意： 在 Error 方法内调用 fmt.Sprint(e) 会让程序陷入死循环。可以通过先转换 e 来避免这个问题：fmt.Sprint(float64(e))。这是为什么呢？ 修改 Sqrt 函数，使其接受一个负数时，返回 ErrNegativeSqrt 值。 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;math&quot;)func Sqrt(x float64) (float64, error) &#123; if x &lt; 0 &#123; return x, ErrNegativeSqrt(x) &#125; return math.Sqrt(x), nil&#125;type ErrNegativeSqrt float64func (e ErrNegativeSqrt) Error() string &#123; return fmt.Sprintf(&quot;cannot Sqrt negative number: %v&quot;, float64(e))&#125;func main() &#123; fmt.Println(Sqrt(2)) fmt.Println(Sqrt(-2))&#125;/*1.4142135623730951 &lt;nil&gt;-2 cannot Sqrt negative number: -2*/ Readerio 包指定了 io.Reader 接口，它表示从数据流的末尾进行读取。 Go 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。 io.Reader 接口有一个 Read 方法： func (T) Read(b []byte) (n int, err error)Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。 示例代码创建了一个 strings.Reader 并以每次 8 字节的速度读取它的输出。 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;strings&quot;)func main() &#123; r := strings.NewReader(&quot;Hello, Reader!&quot;) b := make([]byte, 8) for &#123; n, err := r.Read(b) fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b) fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n]) if err == io.EOF &#123; break &#125; &#125;&#125;/*n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]b[:n] = &quot;Hello, R&quot;n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]b[:n] = &quot;eader!&quot;n = 0 err = EOF b = [101 97 100 101 114 33 32 82]b[:n] = &quot;&quot;*/ 练习：Reader实现一个 Reader 类型，它产生一个 ASCII 字符 ‘A’ 的无限流。 12345678910111213141516171819package mainimport &quot;golang.org/x/tour/reader&quot;type MyReader struct&#123;&#125;// TODO: Add a Read([]byte) (int, error) method to MyReader.func (mr MyReader) Read(b []byte) (int, error)&#123; b[0] = &apos;A&apos; return 1, nil&#125;func main() &#123; reader.Validate(MyReader&#123;&#125;)&#125;// OK! 练习：rot13Reader有种常见的模式是一个 io.Reader 包装另一个 io.Reader，然后通过某种方式修改其数据流。 例如，gzip.NewReader 函数接受一个 io.Reader（已压缩的数据流）并返回一个同样实现了 io.Reader 的 *gzip.Reader（解压后的数据流）。 编写一个实现了 io.Reader 并从另一个 io.Reader 中读取数据的 rot13Reader，通过应用 rot13 代换密码对数据流进行修改。 rot13Reader 类型已经提供。实现 Read 方法以满足 io.Reader。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;io&quot; &quot;os&quot; &quot;strings&quot;)type rot13Reader struct &#123; r io.Reader&#125;func rot13(out byte) byte &#123; switch &#123; case out &gt;= &apos;A&apos; &amp;&amp; out &lt;= &apos;M&apos; || out &gt;= &apos;a&apos; &amp;&amp; out &lt;= &apos;m&apos;: out += 13 case out &gt;= &apos;N&apos; &amp;&amp; out &lt;= &apos;Z&apos; || out &gt;= &apos;a&apos; &amp;&amp; out &lt;= &apos;z&apos;: out -= 13 &#125; return out&#125;func (fz rot13Reader) Read(b []byte) (int, error) &#123; n, e := fz.r.Read(b) for i := 0; i &lt; n; i++ &#123; b[i] = rot13(b[i]) &#125; return n, e&#125;func main() &#123; s := strings.NewReader(&quot;Lbh penpxrq gur pbqr!&quot;) r := rot13Reader&#123;s&#125; io.Copy(os.Stdout, &amp;r)&#125;// You cracked the code! 图像image 包定义了 Image 接口： package image type Image interface { ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color}注意： Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明。 （请参阅文档了解全部信息。） color.Color 和 color.Model 类型也是接口，但是通常因为直接使用预定义的实现 image.RGBA 和 image.RGBAModel 而被忽视了。这些接口和类型由 image/color 包定义。 1234567891011121314package mainimport ( &quot;fmt&quot; &quot;image&quot;)func main() &#123; m := image.NewRGBA(image.Rect(0, 0, 100, 100)) fmt.Println(m.Bounds()) fmt.Println(m.At(0, 0).RGBA())&#125;// (0,0)-(100,100)// 0 0 0 0 练习：图像还记得之前编写的图片生成器吗？我们再来编写另外一个，不过这次它将会返回一个 image.Image 的实现而非一个数据切片。 定义你自己的 Image 类型，实现必要的方法并调用 pic.ShowImage。 Bounds 应当返回一个 image.Rectangle ，例如 image.Rect(0, 0, w, h)。 ColorModel 应当返回 color.RGBAModel。 At 应当返回一个颜色。上一个图片生成器的值 v 对应于此次的 color.RGBA{v, v, 255, 255}。 123456789101112131415161718192021222324252627package mainimport ( &quot;golang.org/x/tour/pic&quot; &quot;image/color&quot; &quot;image&quot;)type Image struct&#123;&#125; //新建一个Image结构体func (i Image) ColorModel() color.Model&#123; //实现Image包中颜色模式的方法 return color.RGBAModel&#125;func (i Image) Bounds() image.Rectangle&#123; //实现Image包中生成图片边界的方法 return image.Rect(0,0,200,200)&#125;func (i Image) At(x,y int) color.Color&#123; //实现Image包中生成图像某个点的方法 return color.RGBA&#123;uint8(x),uint8(y),uint8(255),uint8(255)&#125;&#125;func main() &#123; m := Image&#123;&#125; pic.ShowImage(m) //调用&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习笔记一]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FGo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[变量声明 声明却未使用的变量会报错 12345678910111213141516171819202122231. 声明和赋值var a i n tvar b boola = 15b = false2. 声明并赋值s := &apos;hello&apos;3.多变量声明var x, y int //让 x 和 y 都是 int类型变量a, b := 20, 16 // 让 a 和 b 都是整数变量，并且赋值 20 给 a，16 给 b。var ( x int b bool)一个特殊的变量名是 _（下划线）。任何赋给它的值都被丢弃。在这个例子中，将 35赋值给 b，同时丢弃 34。_, b := 34, 35 短变量声明在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。 下面这种方式会报错 1234567891011package mainimport &quot;fmt&quot;test := 123 // syntax error: non-declaration statement outside function bodyfunc main() &#123; var i, j int = 1, 2 k := 3 c, python, java := true, false, &quot;no!&quot; fmt.Println(i, j, k, c, python, java)&#125; 内建函数12345678910111213append()append 可接受多个参数，但只能接受两个数组eg: s0 := []int&#123;0, 0&#125; s1 := append(s0, 2) s2 := append(s1, 3, 5, 6, 7) s3 := append(s2, s1...) // ok s4 := append(s2, s1..., 1) // syntax error: unexpected literal 2, expecting ) s5 := append(s2, 1, s1...) // error too many arguments to append s6 := append(s2, s1..., s0...) //syntax error: unexpected literal 2, expecting ) fmt格式“占位符”普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式。 Printf(“%v”, people) {zhangsan} %+v 打印结构体时，会添加字段名 Printf(“%+v”, people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(“#v”, people) main.Human{Name:”zhangsan”} %T 相应值的类型的Go语法表示 Printf(“%T”, people) main.Human %% 字面上的百分号，并非值的占位符 Printf(“%%”) % 布尔占位符 占位符 说明 举例 输出 %t true 或 false。 Printf(“%t”, true) true 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(“%b”, 5) 101 %c 相应Unicode码点所表示的字符 Printf(“%c”, 0x4E2D) 中 %d 十进制表示 Printf(“%d”, 0x12) 18 %o 八进制表示 Printf(“%d”, 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(“%q”, 0x4E2D) ‘中’ %x 十六进制表示，字母形式为小写 a-f Printf(“%x”, 13) d %X 十六进制表示，字母形式为大写 A-F Printf(“%x”, 13) D %U Unicode格式：U+1234，等同于 “U+%04X” Printf(“%U”, 0x4E2D) U+4E2D 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %b 无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat 的 ‘b’ 转换格式一致。例如 -123456p-78 %e 科学计数法，例如 -1234.456e+78 Printf(“%e”, 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(“%e”, 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(“%f”, 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0） 输出 Printf(“%g”, 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0） 输出 Printf(“%G”, 10.20+2i) (10.2+2i) 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(“%s”, []byte(“Go语言”)) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(“%q”, “Go语言”) “Go语言” %x 十六进制，小写字母，每字节两个字符 Printf(“%x”, “golang”) 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(“%X”, “golang”) 676F6C616E67 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(“%p”, &amp;people) 0x4f57f0 其他标记 占位符 说明 + 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 Printf(“%+q”, “中文”) “\u4e2d\u6587” - 在右侧而非左侧填充空格（左对齐该区域） # 备用格式：为八进制添加前导 0（%#o） Printf(“%#U”, ‘中’) U+4E2D为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x；如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串；如果是可打印字符，%U（%#U）会写出该字符的Unicode 编码形式（如字符 x 会被打印成 U+0078 ‘x’）。 ‘ ‘ (空格)为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开 0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 forGo 只有一种循环结构：for 循环。 基本的 for 循环由三部分组成，它们用分号隔开： 初始化语句：在第一次迭代前执行 条件表达式：在每次迭代前求值 后置语句：在每次迭代的结尾执行 初始化语句通常为一句短变量声明，==该变量声明仅在 for 语句的作用域中可见。== 一旦条件表达式的布尔值为 false，循环迭代就会终止。 ==注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for语句后面没有小括号，大括号 { } 则是必须的。== 123456789101112package mainimport &quot;fmt&quot;func main() &#123; sum := 0 for i := 0; i &lt; 10; i++ &#123; sum += i &#125; fmt.Println(sum) // 45 fmt.Println(i) // undefined: i (该变量声明仅在 for 语句的作用域中可见)&#125; ==初始化语句和后置语句是可选的。== 1234567891011package mainimport &quot;fmt&quot;func main() &#123; sum := 1 for ; sum &lt; 1000; &#123; sum += sum &#125; fmt.Println(sum) // 1024&#125; ==for 是 Go 中的 “while”== 1234567891011package mainimport &quot;fmt&quot;func main() &#123; sum := 1 for sum &lt; 1000 &#123; sum += sum &#125; fmt.Println(sum) // 1024&#125; ==无限循环== 如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。 12345678package mainfunc main() &#123; for &#123; &#125;&#125;// process took too long ifGo 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 {}则是必须的。 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;math&quot;)func sqrt(x float64) string &#123; if x &lt; 0 &#123; return sqrt(-x) + &quot;i&quot; &#125; return fmt.Sprint(math.Sqrt(x))&#125;func main() &#123; fmt.Println(sqrt(2), sqrt(-4)) // 1.4142135623730951 2i&#125; if 的简短语句同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。 ==该语句声明的变量作用域仅在 if 之内。== 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;math&quot;)func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; return lim // 如果改为 return v 就会报 undefined: v&#125;func main() &#123; fmt.Println( pow(3, 2, 10), // 9 pow(3, 3, 20), // 20 )&#125; if 和 else在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;math&quot;)func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; else &#123; fmt.Printf(&quot;%g &gt;= %g\n&quot;, v, lim) &#125; // 这里开始就不能使用 v 了 return lim&#125;func main() &#123; fmt.Println( pow(3, 2, 10), pow(3, 3, 20), )&#125;// 27 &gt;= 20// 9 20原因：（在 main 的 fmt.Println 调用开始前，两次对 pow的调用均已执行并返回。），可以理解为main中fmt.Println在接收到pow的返回值时才有输出 练习：循环与函数为了练习函数与循环，我们来实现一个平方根函数：用牛顿法实现平方根函数。 计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测： z -= (zz - x) / (2z)重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。 在提供的 func Sqrt 中实现它。无论输入是什么，对 z 的一个恰当的猜测为 1。 要开始，请重复计算 10 次并随之打印每次的 z 值。观察对于不同的值 x（1、2、3 …）， 你得到的答案是如何逼近结果的，猜测提升的速度有多快。 提示：用类型转换或浮点数语法来声明并初始化一个浮点数值： z := 1.0z := float64(1)然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数大于还是小于 10。 尝试改变 z 的初始猜测，如 x 或 x/2。你的函数结果与标准库中的 math.Sqrt 接近吗？ （注：如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x）的距离，除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。这种通用方法叫做牛顿法。它对很多函数，特别是平方根而言非常有效。） 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;time&quot;)func Sqrt(x float64) float64 &#123; z := float64(2) for i := 0; i &lt; 10; i++ &#123; z -= (z*z - x) / (2 * z) &#125; return z&#125;func main() &#123; fmt.Println(Sqrt(2))&#125; switchswitch 是编写一连串 if - else 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。 Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。 除非以 fallthrough 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;runtime&quot;)func main() &#123; fmt.Print(&quot;Go runs on &quot;) switch os := runtime.GOOS; os &#123; case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.&quot;, os) &#125;&#125;// Go runs on nacl. switch 的求值顺序switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。 12345678（例如，switch i &#123;case 0:case f():&#125;在 i==0 时 f 不会被调用。） 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; fmt.Println(&quot;When&apos;s Saturday?&quot;) today := time.Now().Weekday() switch time.Saturday &#123; case today + 0: fmt.Println(&quot;Today.&quot;) case today + 1: fmt.Println(&quot;Tomorrow.&quot;) case today + 2: fmt.Println(&quot;In two days.&quot;) default: fmt.Println(&quot;Too far away.&quot;) &#125;&#125;// When&apos;s Saturday?// Too far away. 没有条件的 switch没有条件的 switch 同 switch true 一样。 这种形式能将一长串 if-then-else 写得更加清晰。 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; t := time.Now() switch &#123; case t.Hour() &lt; 12: fmt.Println(&quot;Good morning!&quot;) case t.Hour() &lt; 17: fmt.Println(&quot;Good afternoon.&quot;) default: fmt.Println(&quot;Good evening.&quot;) &#125;&#125; // Good afternoon. deferdefer 语句会将函数推迟到外层函数返回之后执行。 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。 123456789101112package mainimport &quot;fmt&quot;func main() &#123; defer fmt.Println(&quot;world&quot;) fmt.Println(&quot;hello&quot;)&#125;//hello//world defer 栈推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。 更多关于 defer 语句的信息，请阅读此博文。 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;counting&quot;) for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125; fmt.Println(&quot;done&quot;)&#125; 指针123456789101112131415161718Go 拥有指针。指针保存了值的内存地址。类型 *T 是指向 T 类型值的指针。其零值为 nil。var p *int&amp; 操作符会生成一个指向其操作数的指针。i := 42p = &amp;i* 操作符表示指针指向的底层值。fmt.Println(*p) // 通过指针 p 读取 i*p = 21 // 通过指针 p 设置 i这也就是通常所说的“间接引用”或“重定向”。与 C 不同，Go 没有指针运算。 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() &#123; i, j := 42, 2701 p := &amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = &amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the new value of j&#125;// 42// 21// 73 结构体一个结构体（struct）就是一个字段的集合。 123456789101112131415package mainimport &quot;fmt&quot;type Vertex struct &#123; X int Y int&#125;func main() &#123; fmt.Println(Vertex&#123;1, 2&#125;)&#125;// &#123;1 2&#125; 结构体字段结构体字段使用点号来访问。 12345678910111213141516package mainimport &quot;fmt&quot;type Vertex struct &#123; X int Y int&#125;func main() &#123; v := Vertex&#123;1, 2&#125; v.X = 4 fmt.Println(v.X)&#125;// 4 结构体指针结构体字段可以通过结构体指针来访问。 如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。 1234567891011121314151617package mainimport &quot;fmt&quot;type Vertex struct &#123; X int Y int&#125;func main() &#123; v := Vertex&#123;1, 2&#125; p := &amp;v p.X = 1e9 fmt.Println(v)&#125;// &#123;1000000000 2&#125; 结构体文法结构体文法通过直接列出字段的值来新分配一个结构体。 使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。） 特殊的前缀 &amp; 返回一个指向结构体的指针。 1234567891011121314151617181920package mainimport &quot;fmt&quot;type Vertex struct &#123; X, Y int&#125;var ( v1 = Vertex&#123;1, 2&#125; // has type Vertex v2 = Vertex&#123;X: 1&#125; // Y:0 is implicit v3 = Vertex&#123;&#125; // X:0 and Y:0 p = &amp;Vertex&#123;1, 2&#125; // has type *Vertex)func main() &#123; fmt.Println(v1, p, v2, v3)&#125; // &#123;1 2&#125; &amp;&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125; 数组类型 [n]T 表示拥有 n 个 T 类型的值的数组。 表达式 var a [10]int会将变量 a 声明为拥有有 10 个整数的数组。 数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; var a [2]string a[0] = &quot;Hello&quot; a[1] = &quot;World&quot; fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; fmt.Println(primes)&#125;// Hello World// [Hello World]// [2 3 5 7 11 13] 切片每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。 类型 []T 表示一个元素类型为 T 的切片。 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔： a[low : high] 它会选择一个半开区间，包括第一个元素，但排除最后一个元素。 以下表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素： a[1:4] 1234567891011package mainimport &quot;fmt&quot;func main() &#123; primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; var s []int = primes[1:4] fmt.Println(s)&#125;// [3 5 7] 切片就像数组的引用切片并不存储任何数据，它只是描述了底层数组中的一段。 更改切片的元素会修改其底层数组中对应的元素。 与它共享底层数组的切片都会观测到这些修改。 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() &#123; names := [4]string&#123; &quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &#125; fmt.Println(names) a := names[0:2] b := names[1:3] fmt.Println(a, b) b[0] = &quot;XXX&quot; fmt.Println(a, b) fmt.Println(names)&#125;// [John Paul George Ringo]// [John Paul] [Paul George]// [John XXX] [XXX George]// [John XXX George Ringo] 切片文法切片文法类似于没有长度的数组文法。 这是一个数组文法： [3]bool{true, true, false} 下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片： []bool{true, true, false} 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() &#123; q := []int&#123;2, 3, 5, 7, 11, 13&#125; fmt.Println(q) r := []bool&#123;true, false, true, true, false, true&#125; fmt.Println(r) s := []struct &#123; i int b bool &#125;&#123; &#123;2, true&#125;, &#123;3, false&#125;, &#123;5, true&#125;, &#123;7, true&#125;, &#123;11, false&#125;, &#123;13, true&#125;, &#125; fmt.Println(s)&#125;// [2 3 5 7 11 13]// [true false true true false true]// [&#123;2 true&#125; &#123;3 false&#125; &#123;5 true&#125; &#123;7 true&#125; &#123;11 false&#125; &#123;13 true&#125;] 切片的默认行为在进行切片时，你可以利用它的默认行为来忽略上下界。 切片下界的默认值为 0，上界则是该切片的长度。 对于数组 var a [10]int 来说，以下切片是等价的： a[0:10]a[:10]a[0:]a[:] 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; s := []int&#123;2, 3, 5, 7, 11, 13&#125; s = s[1:4] fmt.Println(s) s = s[:2] fmt.Println(s) s = s[1:] fmt.Println(s)&#125;// [3 5 7]// [3 5]// [5] 切片的长度与容量切片拥有 长度 和 容量。 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。 你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。 123456789101112131415161718192021222324252627package mainimport &quot;fmt&quot;func main() &#123; s := []int&#123;2, 3, 5, 7, 11, 13&#125; printSlice(s) //len=6 cap=6 [2 3 5 7 11 13] // Slice the slice to give it zero length. s = s[:0] printSlice(s) //len=0 cap=6 [] // Extend its length. s = s[:4] printSlice(s) // len=4 cap=6 [2 3 5 7] //超过边界 = 重新切片 // Drop its first two values. s = s[2:] printSlice(s) // len=2 cap=4 [5 7]&#125;func printSlice(s []int) &#123; fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)&#125; 结果 1234len=6 cap=6 [2 3 5 7 11 13]len=0 cap=6 []len=4 cap=6 [2 3 5 7]len=2 cap=4 [5 7] 注：以上程序说明==超过边界 = 重新切片== nil 切片切片的零值是 nil。 nil 切片的长度和容量为 0 且没有底层数组。 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; var s []int fmt.Println(s, len(s), cap(s)) // [] 0 0 if s == nil &#123; fmt.Println(&quot;nil!&quot;) // nil! &#125;&#125;//[] 0 0//nil! 用 make 创建切片切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。 make 函数会分配一个元素为零值的数组并返回一个引用了它的切片： a := make([]int, 5) // len(a)=5要指定它的容量，需向 make 传入第三个参数： b := make([]int, 0, 5) // len(b)=0, cap(b)=5 b = b[:cap(b)] // len(b)=5, cap(b)=5b = b[1:] // len(b)=4, cap(b)=4 123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main() &#123; a := make([]int, 5) printSlice(&quot;a&quot;, a) b := make([]int, 0, 5) printSlice(&quot;b&quot;, b) c := b[:2] printSlice(&quot;c&quot;, c) d := c[2:5] printSlice(&quot;d&quot;, d)&#125;func printSlice(s string, x []int) &#123; fmt.Printf(&quot;%s len=%d cap=%d %v\n&quot;, s, len(x), cap(x), x)&#125;/**a len=5 cap=5 [0 0 0 0 0]b len=0 cap=5 []c len=2 cap=5 [0 0]d len=3 cap=3 [0 0 0]*/ 切片的切片切片可包含任何类型，甚至包括其它的切片。切片类似js的数组，这里的意思是可以操作切片的元素 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() &#123; // Create a tic-tac-toe board. board := [][]string&#123; []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, &#125; // The players take turns. board[0][0] = &quot;X&quot; board[2][2] = &quot;O&quot; board[1][2] = &quot;X&quot; board[1][0] = &quot;O&quot; board[0][2] = &quot;X&quot; for i := 0; i &lt; len(board); i++ &#123; fmt.Printf(&quot;%s\n&quot;, strings.Join(board[i], &quot; &quot;)) &#125;&#125;/**X _ XO _ X_ _ O*/ 向切片追加元素为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数。内建函数的文档对此函数有详细的介绍。 func append(s []T, vs …T) []Tappend 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。 append 的结果是一个包含原切片所有元素加上新添加元素的切片。 当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。 （要了解关于切片的更多内容，请阅读文章 Go 切片：用法和本质。） 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;func main() &#123; var s []int printSlice(s) // append works on nil slices. s = append(s, 0) s = s[:] printSlice(s) // The slice grows as needed. s = append(s, 1) printSlice(s) // We can add more than one element at a time. s = append(s, 2, 3, 4) printSlice(s)&#125;func printSlice(s []int) &#123; fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)&#125;/**len=0 cap=0 []len=1 cap=1 [0]len=2 cap=2 [0 1]len=5 cap=6 [0 1 2 3 4]*/ 注：==这里所说的扩容的计算方式，是在原底层数组容量基础上进行倍数增加== 如上述程序 123456789101112131415s = append(s, 2, 3, 4)printSlice(s)//len=5 cap=6 [0 1 2 3 4]若改为s = append(s, 2, 3, 4, 5, 6)printSlice(s)则结果为//len=7 cap=8 [0 1 2 3 4 5 6]就是在原数组容量为2的基数上进行倍乘 Rangefor 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，==第二个值为该下标所对应元素的一份副本。== 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;func main() &#123; for i, v := range pow &#123; fmt.Printf(&quot;2**%d = %d\n&quot;, i, v) &#125;&#125;/**2**0 = 12**1 = 22**2 = 42**3 = 82**4 = 162**5 = 322**6 = 642**7 = 128*/ 可以将下标或值赋予 _ 来忽略它。 若你只需要索引，去掉 , value 的部分即可。 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() &#123; pow := make([]int, 10) for i := range pow &#123; pow[i] = 1 &lt;&lt; uint(i) // == 2**i &#125; for _, value := range pow &#123; fmt.Printf(&quot;%d\n&quot;, value) &#125;&#125;/**1248163264128256*/ 练习：切片实现 Pic。它应当返回一个长度为 dy 的切片，其中每个元素是一个长度为 dx，元素类型为 uint8 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。 图像的选择由你来定。几个有趣的函数包括 (x+y)/2, xy, x^y, xlog(y) 和 x%(y+1)。 （提示：需要使用循环来分配 [][]uint8 中的每个 []uint8；请使用 uint8(intValue) 在类型之间转换；你可能会用到 math 包中的函数。） 分析：1、返回一个切片长度为dy2、这个切片的每个元素长度为dx3、每个元素的之为(x+y)/2 || xy || x^y || xlog(y) || x%(y+1) 123456789101112131415161718192021222324package mainimport &quot;golang.org/x/tour/pic&quot;func Pic(dx, dy int) [][]uint8 &#123; a := make([][]uint8, dy) for x := range a &#123; b := make([]uint8, dx) for y := range b &#123; b[y] = uint8(x*y) // uint8(x*y) || uint8((x+y)/2) || uint8( x^y) || x*log(y) || x%(y+1) &#125; a[x] = b &#125; return a &#125;func main() &#123; pic.Show(Pic)&#125; 映射映射将键映射到值。 映射的零值为 nil 。nil 映射既没有键，也不能添加键。 make 函数会返回给定类型的映射，并将其初始化备用。 123456789101112131415161718192021package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m map[string]Vertexfunc main() &#123; m = make(map[string]Vertex) m[&quot;Bell Labs&quot;] = Vertex&#123; 40.68433, -74.39967, &#125; fmt.Println(m[&quot;Bell Labs&quot;])&#125;/**&#123;40.68433 -74.39967&#125;*/ 映射的文法映射的文法与结构体相似，不过必须有键名。 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m = map[string]Vertex&#123; &quot;Bell Labs&quot;: Vertex&#123; 40.68433, -74.39967, &#125;, &quot;Google&quot;: Vertex&#123; 37.42202, -122.08408, &#125;,&#125;func main() &#123; fmt.Println(m)&#125;/**map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;]*/ 若顶级类型只是一个类型名，你可以在文法的元素中省略它。 1234567891011121314151617181920package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m = map[string]Vertex&#123; &quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;, &quot;Google&quot;: &#123;37.42202, -122.08408&#125;,&#125;func main() &#123; fmt.Println(m)&#125;// map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;] 修改映射在映射 m 中插入或修改元素： m[key] = elem获取元素： elem = m[key]删除元素： delete(m, key)通过双赋值检测某个键是否存在： elem, ok = m[key]若 key 在 m 中，ok 为 true；否则，ok 为 false。 若 key 不在映射中，那么 elem 是该映射元素类型的零值。 同样的，当从 映射 中读取某个不存在的键时，结果是 映射 的元素类型的零值。 注 ：若 elem 或 ok 还未声明，你可以使用短变量声明： elem, ok := m[key] 123456789101112131415161718192021222324252627package mainimport &quot;fmt&quot;func main() &#123; m := make(map[string]int) m[&quot;Answer&quot;] = 42 fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;]) m[&quot;Answer&quot;] = 48 fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;]) delete(m, &quot;Answer&quot;) fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;]) v, ok := m[&quot;Answer&quot;] fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)&#125;/**The value: 42The value: 48The value: 0The value: 0 Present? false*/ 练习：映射实现 WordCount。它应当返回一个映射，其中包含字符串 s 中每个“单词”的个数。函数 wc.Test 会对此函数执行一系列测试用例，并输出成功还是失败。 你会发现 strings.Fields 很有帮助。 12345678910111213package mainimport ( &quot;golang.org/x/tour/wc&quot;)func WordCount(s string) map[string]int &#123; return map[string]int&#123;&quot;x&quot;: 1&#125;&#125;func main() &#123; wc.Test(WordCount)&#125; 答案 1234567891011121314151617181920package mainimport ( &quot;golang.org/x/tour/wc&quot; &quot;strings&quot;)func WordCount(s string) map[string]int &#123; ret := make(map[string]int) arr := strings.Fields(s) for _, val := range arr &#123; ret[val]++ &#125; return ret&#125;func main() &#123; wc.Test(WordCount)&#125; 函数值函数也是值。它们可以像其它值一样传递。 函数值可以用作函数的参数或返回值。 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot; &quot;math&quot;)func compute(fn func(float64, float64) float64) float64 &#123; return fn(3, 4)&#125;func main() &#123; hypot := func(x, y float64) float64 &#123; return math.Sqrt(x*x + y*y) &#125; fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow))&#125;/**13581*/ 函数的闭包Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。 例如，函数 adder 返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上。 12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125;&#125;/**0 01 -23 -66 -1210 -2015 -3021 -4228 -5636 -7245 -90*/ 练习：斐波纳契闭包让我们用函数做些好玩的事情。 实现一个 fibonacci 函数，它返回一个函数（闭包），该闭包返回一个斐波纳契数列 (0, 1, 1, 2, 3, 5, ...)。 原题 12345678910111213141516package mainimport &quot;fmt&quot;// fibonacci is a function that returns// a function that returns an int.func fibonacci() func() int &#123;&#125;func main() &#123; f := fibonacci() for i := 0; i &lt; 10; i++ &#123; fmt.Println(f()) &#125;&#125; 答案 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;// fibonacci is a function that returns// a function that returns an int.func fibonacci() func() int &#123;&#125;func main() &#123; f := fibonacci() for i := 0; i &lt; 10; i++ &#123; fmt.Println(f()) &#125;&#125;/**0112358132134*/]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go指针]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FGo%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针Go 拥有指针。指针保存了值的内存地址。类型 *T 是指向 T 类型值的指针。其零值为 nil。 var p *int &amp; 操作符会生成一个指向其操作数的指针。12i := 42p = &amp;i 操作符表示指针指向的底层值。 fmt.Println(*p) // 通过指针 p 读取 i *p = 21 // 通过指针 p 设置 i 这也就是通常所说的“间接引用”或“重定向”。 与 C 不同，Go 没有指针运算。 注：指针相当于js中数组或对象的引用]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go流程控制语句：for ,if ,else, switch, defer]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FGo%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9Afor%20%2Cif%20%2Celse%2C%20switch%2C%20defer%2F</url>
    <content type="text"><![CDATA[forGo 只有一种循环结构：for 循环。基本的 for 循环由三部分组成，它们用分号隔开： 初始化语句：在第一次迭代前执行 条件表达式：在每次迭代前求值 后置语句：在每次迭代的结尾执行 初始化语句通常为一句短变量声明，==该变量声明仅在 for 语句的作用域中可见。==一旦条件表达式的布尔值为 false，循环迭代就会终止。 ==注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for语句后面没有小括号，大括号 { } 则是必须的。== 123456789101112package mainimport &quot;fmt&quot;func main() &#123; sum := 0 for i := 0; i &lt; 10; i++ &#123; sum += i &#125; fmt.Println(sum) // 45 fmt.Println(i) // undefined: i (该变量声明仅在 for 语句的作用域中可见)&#125; ==初始化语句和后置语句是可选的。== 1234567891011package mainimport &quot;fmt&quot;func main() &#123; sum := 1 for ; sum &lt; 1000; &#123; sum += sum &#125; fmt.Println(sum) // 1024&#125; ==for 是 Go 中的 “while”== 1234567891011package mainimport &quot;fmt&quot;func main() &#123; sum := 1 for sum &lt; 1000 &#123; sum += sum &#125; fmt.Println(sum) // 1024&#125; ==无限循环== 如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。 12345678package mainfunc main() &#123; for &#123; &#125;&#125;// process took too long ifGo 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 {}则是必须的。 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;math&quot;)func sqrt(x float64) string &#123; if x &lt; 0 &#123; return sqrt(-x) + &quot;i&quot; &#125; return fmt.Sprint(math.Sqrt(x))&#125;func main() &#123; fmt.Println(sqrt(2), sqrt(-4)) // 1.4142135623730951 2i&#125; if 的简短语句同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。 ==该语句声明的变量作用域仅在 if 之内。== 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;math&quot;)func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; return lim // 如果改为 return v 就会报 undefined: v&#125;func main() &#123; fmt.Println( pow(3, 2, 10), // 9 pow(3, 3, 20), // 20 )&#125; if 和 else在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;math&quot;)func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; else &#123; fmt.Printf(&quot;%g &gt;= %g\n&quot;, v, lim) &#125; // 这里开始就不能使用 v 了 return lim&#125;func main() &#123; fmt.Println( pow(3, 2, 10), pow(3, 3, 20), )&#125;// 27 &gt;= 20// 9 20原因：（在 main 的 fmt.Println 调用开始前，两次对 pow的调用均已执行并返回。），可以理解为main中fmt.Println在接收到pow的返回值时才有输出 练习：循环与函数为了练习函数与循环，我们来实现一个平方根函数：用牛顿法实现平方根函数。 计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测： z -= (zz - x) / (2z)重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。 在提供的 func Sqrt 中实现它。无论输入是什么，对 z 的一个恰当的猜测为 1。 要开始，请重复计算 10 次并随之打印每次的 z 值。观察对于不同的值 x（1、2、3 …）， 你得到的答案是如何逼近结果的，猜测提升的速度有多快。 提示：用类型转换或浮点数语法来声明并初始化一个浮点数值： z := 1.0z := float64(1)然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数大于还是小于 10。 尝试改变 z 的初始猜测，如 x 或 x/2。你的函数结果与标准库中的 math.Sqrt 接近吗？ （注：如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x）的距离，除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。这种通用方法叫做牛顿法。它对很多函数，特别是平方根而言非常有效。） 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;time&quot;)func Sqrt(x float64) float64 &#123; z := float64(2) for i := 0; i &lt; 10; i++ &#123; z -= (z*z - x) / (2 * z) &#125; return z&#125;func main() &#123; fmt.Println(Sqrt(2))&#125; switchswitch 是编写一连串 if - else 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。 Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。 除非以 fallthrough 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;runtime&quot;)func main() &#123; fmt.Print(&quot;Go runs on &quot;) switch os := runtime.GOOS; os &#123; case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.&quot;, os) &#125;&#125;// Go runs on nacl. switch 的求值顺序switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。 12345678（例如，switch i &#123;case 0:case f():&#125;在 i==0 时 f 不会被调用。） 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; fmt.Println(&quot;When&apos;s Saturday?&quot;) today := time.Now().Weekday() switch time.Saturday &#123; case today + 0: fmt.Println(&quot;Today.&quot;) case today + 1: fmt.Println(&quot;Tomorrow.&quot;) case today + 2: fmt.Println(&quot;In two days.&quot;) default: fmt.Println(&quot;Too far away.&quot;) &#125;&#125;// When&apos;s Saturday?// Too far away. 没有条件的 switch没有条件的 switch 同 switch true 一样。 这种形式能将一长串 if-then-else 写得更加清晰。 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; t := time.Now() switch &#123; case t.Hour() &lt; 12: fmt.Println(&quot;Good morning!&quot;) case t.Hour() &lt; 17: fmt.Println(&quot;Good afternoon.&quot;) default: fmt.Println(&quot;Good evening.&quot;) &#125;&#125; // Good afternoon. deferdefer 语句会将函数推迟到外层函数返回之后执行。 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。 123456789101112package mainimport &quot;fmt&quot;func main() &#123; defer fmt.Println(&quot;world&quot;) fmt.Println(&quot;hello&quot;)&#125;//hello//world defer 栈推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。 更多关于 defer 语句的信息，请阅读此博文。 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;counting&quot;) for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125; fmt.Println(&quot;done&quot;)&#125; 指针123456789101112131415161718Go 拥有指针。指针保存了值的内存地址。类型 *T 是指向 T 类型值的指针。其零值为 nil。var p *int&amp; 操作符会生成一个指向其操作数的指针。i := 42p = &amp;i* 操作符表示指针指向的底层值。fmt.Println(*p) // 通过指针 p 读取 i*p = 21 // 通过指针 p 设置 i这也就是通常所说的“间接引用”或“重定向”。与 C 不同，Go 没有指针运算。 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() &#123; i, j := 42, 2701 p := &amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = &amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the new value of j&#125;// 42// 21// 73]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go函数]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FGo%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[多返回值 函数和方法可以返回多个值，返回顺序就是声明顺序 1234567891011func testReturn(a int, b []byte) (c int, d []byte) &#123; d = append(b, b...) c += a return&#125;r1, r2 := testReturn(1, []byte&#123;1, 2, 3&#125;)fmt.Printf(&quot;%d\n%v&quot;, r1, r2) //result: // 1// [1 2 3 1 2 3] 延迟代码 defer语句的运用 defer 语句会加入异步执行队列，但是遵循照后进先出（LIFO）的顺序 1234567891011func testDefer() &#123; for i := 0; i &lt; 5; i++ &#123; defer fmt.Printf(&quot;%d\n&quot;, i) &#125;&#125;//result:// 4// 3// 2// 1// 0 修改返回值 123456789func deferPro() (ret int) &#123; defer func() &#123; ret++ &#125;() return 0&#125;// result 1 not 0 变参 什么是变参 接受不定数量的参数的函数叫做变参函数。定义函数使其接受变参： 1func myfunc(arg ...int) &#123; &#125; arg …int 告诉 Go 这个函数接受不定数量的参数。注意，这些参数的类型全部是 int。在函数体中，变量 arg 是一个 int 类型的 slice： 123for _, n := range arg &#123; fmt.Printf(&quot;And the number is: %d\n&quot;, n)&#125; 变参传递 如果不指定变参的类型，默认是空的接口 interface{}（参阅第 5 章）。假设有另一个变参函数叫做 myfunc2，下面的例子演示了如何向其传递变参： 1234func myfunc(arg ...int) &#123; myfunc2(arg...) //按原样传递 myfunc2(arg[:2]...) // 传递部分&#125; 赋值go中有个奇特的地方，两个变量交换值时不用引入第三个变量（原谅我水，不能准确的描述） 1234x, y := 1, 2fmt.Printf(&quot;before: x: %v\t y: %v&quot;, x, y) //before: x: 1 y: 2x, y = y, xfmt.Printf(&quot;after: x: %v\t y: %v&quot;, x, y) //after: x: 2 y: 1 且只能这么写，如果改为下面这样就不行了 12345x, y := 1, 2fmt.Printf(&quot;before: x: %v\t y: %v&quot;, x, y) //before: x: 1 y: 2x = yy = xfmt.Printf(&quot;after: x: %v\t y: %v&quot;, x, y) //after: x: 2 y: 2 匿名函数go的匿名函数不同js优美，个人感觉js灵活强大，跟接近人类语言，是计算机语言的未来（好吧，我承认我只是意淫） go的匿名函数要加上go关键字 go ,别的同js一样的用法 1234go func(param string) &#123; print(param)&#125;(&quot;this is param&quot;) 好像更优雅]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go包]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FGo%E5%8C%85%2F</url>
    <content type="text"><![CDATA[包基础 项目引用自定义的包就是go安装路径下的src下的文件夹名（规范小写） eg： Go/src/mypackage 导入： 123456package mainimport ( &quot;fmt&quot; &quot;mypackage&quot;) 一个包下面可以有多个go文件，文件名在这里没有什么卵用，可以和这个文件内的包名一样也可以不一样 1234567891011121314151617181920212223242526eg: 1. 在Go/src 下新建一个文件 test/test1.go2. test1.go的内容如下:package even func Even(i int) bool &#123; return i%2 == 0&#125;func Odd(i int) bool &#123; return i%2 == 1&#125;3. 在myproject中使用package mainimport ( &quot;fmt&quot; &quot;test&quot;)func main() &#123; i := 5 fmt.Printf(&quot;Is %d even? %v\n&quot;, i, even.Even(i))&#125; 图解： 名称以大写字母起始的是可导出的，可以在包的外部调用 如上名为even的包，如果将其下的Even函数改为even,外面就因拿不到而报错（能导出的我们称为公有函数，外面拿不到的成为私有函数） 公有函数的名字以大写字母开头； 私有函数的名字以小写字母开头。 当包导入（通过 import）时，包名成为了内容的入口。在impor”bytes”之后，导入包的可以调用函数 bytes.Buffer。 包名的命名规范：短的、简洁的、好记的。根据规则，包名是小写的一个单词；不应当有下划线或混合大小写。保持简洁（由于每个人都可能需要录入这个名字），不要过早考虑命名冲突。 包名可以起一个别名, 在import和包名之间 import bar “bytes” 包测试 包测试文件以*_test.go命名，包含在这个包的目录下，包的每个函数否可以进行测试，测试函数的写法都有相同的标识 1func TestXxx(t *testing.T) 编写测试时，需要告诉 go test 测试是失败还是成功。测试成功则直接返回。当测试失败可以用下面的函数标记 1func (t *T) Fail() Fail 标记测试函数失败，但仍然继续执行。 1func (t *T) FailNow() FailNow 标记测试函数失败，并且中断其执行。当前文件中的其余的测试将被跳过，然后执行下一个文件中的测试。 1func (t *T) Log(args ...interface &#123; &#125;) Log 用默认格式对其参数进行格式化，与 Print() 类似，并且记录文本到错误日志。 1func (t *T) Fatal(args ...interface &#123; &#125;) Fatal 等价于 Log() 后跟随 FailNow()。 常用包fmt 包 fmt 实现了格式化的 I/O 函数，这与 C 的 printf 和 scanf 类似。格式化短语派生于 C 。一些短语（%-序列）这样使用： %v 默认格式的值。当打印结构时，加号（%+v）会增加字段名； %#v Go 样式的值表达； %T 带有类型的 Go 样式的值表达； io 这个包提供了原始的 I/O 操作界面。它主要的任务是对 os 包这样的原始的 I/O 进行封装，增加一些其他相关，使其具有抽象功能用在公共的接口上。 bufio 这个包实现了缓冲的 I/O。它封装于 io.Reader 和 io.Writer 对象，创建了另一个对象（Reader 和 Writer）在提供缓冲的同时实现了一些文本 I/O 的功能。 sort sort 包提供了对数组和用户定义集合的原始的排序功能。 trconv strconv 包提供了将字符串转换成基本数据类型，或者从基本数据类型转换为字符串的功能。 os os 包提供了与平台无关的操作系统功能接口。其设计是 Unix 形式的。 sync sync 包提供了基本的同步原语，例如互斥锁。 flag flag 包实现了命令行解析。 encoding/json encoding/json 包实现了编码与解码的 JSON 对象。 html/template 数据驱动的模板，用于生成文本输出，例如 HTML。 将模板关联到某个数据结构上进行解析。模板内容指向数据结构的元素（通常结构的字段或者 map 的键）控制解析并且决定某个值会被显示。模板扫描结构以便解析，而 “游标” @ 决定了当前位置在结构中的值。 net/http net/http 实现了 HTTP 请求、响应和 URL 的解析，并且提供了可扩展的 HTTP 服务和基本的 HTTP 客户端。 unsafe unsafe 包包含了 Go 程序中数据类型上所有不安全的操作。通常无须使用这个。 reflect reflect 包实现了运行时反射，允许程序通过抽象类型操作对象。通常用于处理静态类型 interface{} 的值，并且通过 Typeof 解析出其动态类型信息，通常会返回一个有接口类型 Type 的对象。 os/exec os/exec 包执行外部命令。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON 编码解码总结]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2FJSON%20%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[已知需要编码解码类型的1. 编码 json.NewEncoder().encode(v) json.Marshal(&amp;v) 2. 解码 json.NewDecoder().decode(&amp;v) json.Unmarshal([]byte, &amp;v) 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;bytes&quot; &quot;strings&quot;)type Person struct &#123; Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;`&#125;func main() &#123; // 1. 使用 json.Marshal 编码 person1 := Person&#123;&quot;张三&quot;, 24&#125; bytes1, err := json.Marshal(&amp;person1) if err == nil &#123; // 返回的是字节数组 []byte fmt.Println(&quot;json.Marshal 编码结果: &quot;, string(bytes1)) //json.Marshal 编码结果: &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:24&#125; &#125; // 2. 使用 json.Unmarshal 解码 str := `&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:25&#125;` // json.Unmarshal 需要字节数组参数, 需要把字符串转为 []byte 类型 bytes2 := []byte(str) // 字符串转换为字节数组 var person2 Person // 用来接收解码后的结果 if json.Unmarshal(bytes2, &amp;person2) == nil &#123; fmt.Println(&quot;json.Unmarshal 解码结果: &quot;, person2.Name, person2.Age) //json.Unmarshal 解码结果: 李四 25 &#125; // 3. 使用 json.NewEncoder 编码 person3 := Person&#123;&quot;王五&quot;, 30&#125; // 编码结果暂存到 buffer bytes3 := new(bytes.Buffer) err = json.NewEncoder(bytes3).Encode(person3) if err == nil &#123; fmt.Print(&quot;json.NewEncoder 编码结果: &quot;, string(bytes3.Bytes())) //json.NewEncoder 编码结果: &#123;&quot;name&quot;:&quot;王五&quot;,&quot;age&quot;:30&#125; &#125; // 4. 使用 json.NewDecoder 解码 str4 := `&#123;&quot;name&quot;:&quot;赵六&quot;,&quot;age&quot;:28&#125;` var person4 Person // 创建一个 string reader 作为参数 err = json.NewDecoder(strings.NewReader(str4)).Decode(&amp;person4) if err == nil &#123; fmt.Println(&quot;json.NewDecoder 解码结果: &quot;, person4.Name, person4.Age) //json.NewDecoder 解码结果: 赵六 28 &#125;&#125; 未知类型的(对于需要解码的字符串不知道具体有哪些字段)我们可以使用 interface 接收 json.Unmarshal 的结果，然后利用 type assertion 特性(把解码结果转换为 ==map[string]interface{}== 类型)来进行后续操作。 1234567891011121314151617package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)func main() &#123; b := []byte(`&#123;&quot;Name&quot;:&quot;Wednesday&quot;,&quot;Age&quot;:6,&quot;Parents&quot;:[&quot;Gomez&quot;,&quot;Morticia&quot;]&#125;`) var f interface&#123;&#125; json.Unmarshal(b, &amp;f) m := f.(map[string]interface&#123;&#125;) fmt.Println(m[&quot;Parents&quot;]) // 读取 json 内容 fmt.Println(m[&quot;a&quot;] == nil) // 判断键是否存在&#125; JSON 数组解析 导入”encoding/josn” 包 创建一个解析用的结构体 调用解析方法josn.Unmarshal([]byte(jsonstr), &amp;结构体) 示例代码 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)type Transport struct &#123; Time string MAC string Id string Rssid string&#125;func main() &#123; var st []Transport t1 := Transport&#123;Time: &quot;22&quot;, MAC: &quot;33&quot;, Id: &quot;44&quot;, Rssid: &quot;55&quot;&#125; st = append(st, t1) t2 := Transport&#123;Time: &quot;66&quot;, MAC: &quot;77&quot;, Id: &quot;88&quot;, Rssid: &quot;99&quot;&#125; st = append(st, t2) buf, _ := json.Marshal(st) fmt.Println(string(buf)) var str = string(buf) var st1 []Transport err := json.Unmarshal([]byte(str), &amp;st1) if err != nil &#123; fmt.Println(&quot;some error&quot;) &#125; fmt.Println(st1) fmt.Println(st1[0].Time) var Msg []map[string]string json.Unmarshal([]byte(str), &amp;Msg) fmt.Println(Msg)&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts自适应设置]]></title>
    <url>%2F2019%2F09%2F09%2Fecharts%2Fecharts%E8%87%AA%E9%80%82%E5%BA%94%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[echarts的容器设置了自适应 添加window.onresize=myCharts.resize在setOption之后 12345678910111213141516171819202122232425262728293031323334353637383940414243var worldMapContainer = document.getElementById(&apos;WorldMap&apos;);//用于使chart自适应高度和宽度,通过窗体高宽计算容器高宽var resizeWorldMapContainer = function () &#123; worldMapContainer.style.width = window.innerWidth+&apos;px&apos;; worldMapContainer.style.height = window.innerHeight+&apos;px&apos;;&#125;;//设置容器高宽resizeWorldMapContainer();// 基于准备好的dom，初始化echarts实例var myChart = echarts.init(worldMapContainer);// 指定图表的配置项和数据var option = &#123; title: &#123; text: &apos;ECharts 入门示例&apos; &#125;, tooltip: &#123;&#125;, legend: &#123; data:[&apos;销量&apos;], height: worldMapContainer.style.height, width: worldMapContainer.style.width &#125;, xAxis: &#123; data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;] &#125;, yAxis: &#123;&#125;, series: [&#123; name: &apos;销量&apos;, type: &apos;bar&apos;, data: [5, 20, 36, 10, 10, 20] &#125;]&#125;;// 使用刚指定的配置项和数据显示图表。myChart.setOption(option);//用于使chart自适应高度和宽度window.onresize = function () &#123; //重置容器高宽 resizeWorldMapContainer(); myChart.resize();&#125;; 如果容器设置固定大小则需要 resizeWorldMapContainer()方法 如果容器本身就是自适应样式，则不需要resizeWorldMapContainer()方法]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts设置柱状图交差显示]]></title>
    <url>%2F2019%2F09%2F09%2Fecharts%2Fecharts%E8%AE%BE%E7%BD%AE%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%BA%A4%E5%B7%AE%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[有时候柱状图要做达标率一览，即达标的是一个颜色未达标的另外一个颜色只要在series中的itemStyle中color中设置已颜色列表即可1234567891011121314151617181920212223242526var colorList = [];series : [ &#123; type:&apos;bar&apos;, name:&apos;巡河完成率&apos;, barWidth: &apos;40%&apos;, label: &#123; normal: &#123; show: true, position: &apos;inside&apos;, formatter: &apos;&#123;c&#125;%&apos; &#125; &#125;, itemStyle: &#123; normal:&#123; color: function(params) &#123; return colorList[params.dataIndex] &#125; &#125; &#125;, data: data &#125;]for(var i in option.series[0].data)&#123; colorList[i]=option.series[0].data[i]&gt;70 ? &apos;#F08080&apos; : &apos;#7EC0EE&apos;;&#125;; 完整方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var colorList = [];var option = &#123; legend: &#123; bottom: &quot;12%&quot;, right: 5, orient: &apos;horizontal&apos;, selectedMode:false, textStyle: &#123; color: &apos;#000&apos; &#125;, data:[&apos;巡河完成率&apos;] &#125;, color: [&apos;#3398DB&apos;], tooltip : &#123; /* 坐标轴指示器，坐标轴触发有效*/ trigger: &apos;axis&apos;, axisPointer : &#123; type : &apos;shadow&apos; &#125;, formatter: function(params) &#123; var res = params[0]; return res.axisValue + &apos;&lt;/br&gt;&apos; + res.marker + res.seriesName + &apos;\t&apos; + res.value + &apos;%&apos;; &#125;, backgroundColor : &quot;rgba(255,255,255,1)&quot;, borderWidth: 1, borderColor: &apos;#3399ff&apos;, textStyle: &#123; color: &apos;#494949&apos; &#125;, shadowStyle: &#123; &#125; &#125;, grid: &#123; left: &apos;3%&apos;, bottom: &apos;50px&apos;, containLabel: true, height: &apos;450px&apos; &#125;, xAxis : [ &#123; type : &apos;category&apos;, data : [&apos;玄武区&apos;, &apos;秦淮区&apos;, &apos;鼓楼区&apos;, &apos;建邺区&apos;, &apos;栖霞区&apos;, &apos;雨花台区&apos;, &apos;浦口区&apos;,&apos;江宁区&apos;,&apos;六合区&apos;], axisTick: &#123; alignWithLabel: true &#125; &#125; ], yAxis : [ &#123; type : &apos;value&apos;, axisLabel: &#123; formatter: &apos;&#123;value&#125; %&apos; &#125; &#125; ], series : [ &#123; type:&apos;bar&apos;, name:&apos;巡河完成率&apos;, barWidth: &apos;40%&apos;, label: &#123; normal: &#123; show: true, position: &apos;inside&apos;, formatter: &apos;&#123;c&#125;%&apos; &#125; &#125;, itemStyle: &#123; normal:&#123; color: function(params) &#123; return colorList[params.dataIndex] &#125; &#125; &#125;, data: data &#125; ] &#125;;for(var i in option.series[0].data)&#123; colorList[i]=option.series[0].data[i]&gt;70 ? &apos;#F08080&apos; : &apos;#7EC0EE&apos;;&#125;;obj.setOption(option);]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在饼状图上面标注数据]]></title>
    <url>%2F2019%2F09%2F09%2Fecharts%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A5%BC%E7%8A%B6%E5%9B%BE%E4%B8%8A%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[1.饼状图数据显示 数据直接显示方法在series中使用label，如下所示 12345678910label : &#123; normal : &#123; formatter: &apos;&#123;d&#125;%&apos;, position: &apos;inner&apos;, textStyle : &#123; fontWeight : &apos;normal&apos;, fontSize : 15 &#125; &#125;&#125;, 全部代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function echartZms(obj)&#123; var option = &#123; tooltip : &#123; trigger: &apos;item&apos;, &#125;, legend: &#123; bottom: &quot;5%&quot;, left: &quot;20%&quot;, orient: &apos;horizontal&apos;, selectedMode:false, textStyle: &#123; color: &apos;#fff&apos; &#125;, data: [&apos;已启动&apos;,&apos;未启动&apos;] &#125;, series : [ &#123; type: &apos;pie&apos;, avoidLabelOverlap: false, hoverAnimation:false, /*关闭 hover 在扇区上的放大动画效果。*/ silent:true, radius : &apos;70%&apos;, center: [&apos;50%&apos;, &apos;42%&apos;], label : &#123; normal : &#123; formatter: &apos;&#123;d&#125;%&apos;, position: &apos;inner&apos;, textStyle : &#123; fontWeight : &apos;normal&apos;, fontSize : 15 &#125; &#125; &#125;, data:[&#123; value: 335, name:&apos;已启动&apos;, label:&#123; show:true, position:[20,20] &#125;, itemStyle: &#123; normal: &#123; color: &quot;#167bd7&quot; &#125; &#125; &#125;,&#123; value: 310, name:&apos;未启动&apos;, itemStyle: &#123; normal: &#123; color: &quot;#414d63&quot; &#125; &#125; &#125; ], /*itemStyle: &#123; emphasis: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &apos;rgba(0, 0, 0, 0.5)&apos; &#125; &#125;*/ &#125; ] &#125;; obj.setOption(option);&#125;; 2.环形图数据显示 同样在series中使用lable 123456789101112131415161718label: &#123; normal: &#123; position: &apos;center&apos;, fontSize: 14, formatter: function(obj) &#123; var tit, data = obj.data; if(data.name == &apos;已启动&apos;)&#123; tit = data.value+&apos;%已启动\n\n\n\n&apos;; &#125;else if(data.name == &apos;已关闭&apos;)&#123; tit = data.value+&apos;%已关闭&apos;; &#125;else if(data.name == &apos;已故障&apos;)&#123; tit = &apos;\n\n\n\n&apos;+ data.value+&apos;%已故障&apos;; &#125;; return tit; &#125; &#125;&#125;, 全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var option = &#123; tooltip: &#123; trigger: &apos;item&apos;, formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&quot; &#125;, legend: &#123; bottom: &quot;5%&quot;, left: &quot;5%&quot;, orient: &apos;horizontal&apos;, selectedMode:false, textStyle: &#123; color: &apos;#fff&apos; &#125;, data:[&apos;已启动&apos;,&apos;已关闭&apos;,&apos;已故障&apos;] &#125;, series: [ &#123; type:&apos;pie&apos;, center: [&apos;50%&apos;, &apos;42%&apos;], radius: [&apos;50%&apos;, &apos;70%&apos;], avoidLabelOverlap: false, hoverAnimation:false, /*关闭 hover 在扇区上的放大动画效果。*/ cursor:&apos;default&apos;, /*鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。*/ silent:true, /*图形是否不响应和触发鼠标事件，默认为 false，即响应和触发鼠标事件。*/ label: &#123; normal: &#123; position: &apos;center&apos;, fontSize: 14, formatter: function(obj) &#123; var tit, data = obj.data; if(data.name == &apos;已启动&apos;)&#123; tit = data.value+&apos;%已启动\n\n\n\n&apos;; &#125;else if(data.name == &apos;已关闭&apos;)&#123; tit = data.value+&apos;%已关闭&apos;; &#125;else if(data.name == &apos;已故障&apos;)&#123; tit = &apos;\n\n\n\n&apos;+ data.value+&apos;%已故障&apos;; &#125;; return tit; &#125; &#125; &#125;, data:[ &#123; value: data[1], name:&apos;已启动&apos;, itemStyle: &#123; normal: &#123; color: &quot;#02fb01&quot; &#125; &#125; &#125;, &#123; value: data[0], name:&apos;已关闭&apos;, itemStyle: &#123; normal: &#123; color: &quot;#157ad2&quot; &#125; &#125; &#125;, &#123; value: data[2], name:&apos;已故障&apos;, itemStyle: &#123; normal: &#123; color: &quot;#d14f57&quot; &#125; &#125; &#125; ] &#125; ] &#125; obj.setOption(option);]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts提示框组件设置]]></title>
    <url>%2F2019%2F09%2F09%2Fecharts%2Fecharts%E6%8F%90%E7%A4%BA%E6%A1%86%E7%BB%84%E4%BB%B6%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[如何使用提示框(tooltip的设置)？以柱状图为例 柱状图提示框显示百分比 12345678910tooltip : &#123; trigger: &apos;axis&apos;, axisPointer : &#123; /* 坐标轴指示器，坐标轴触发有效*/ type : &apos;shadow&apos; /* 默认为直线，可选为：&apos;line&apos; | &apos;shadow&apos;*/ &#125;, formatter: function(params) &#123; var res = params[0]; return res.axisValue + &apos;&lt;/br&gt;&apos; + res.marker + res.seriesName + &apos;\t&apos; + res.value + &apos;%&apos;; &#125;&#125;, 自定义数据(文本)格式的重点是打断点查看formatter : function(params) { } 中到的params参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var riverRateB = echarts.init(document.getElementById(&quot;riverRate&quot;));var option = &#123; legend: &#123; bottom: &quot;12%&quot;, right: 5, orient: &apos;horizontal&apos;, selectedMode:false, textStyle: &#123; color: &apos;#000&apos; &#125;, data:[&apos;巡河完成率&apos;] &#125;, color: [&apos;#3398DB&apos;], tooltip : &#123; trigger: &apos;axis&apos;, axisPointer : &#123; /* 坐标轴指示器，坐标轴触发有效*/ type : &apos;shadow&apos; /* 默认为直线，可选为：&apos;line&apos; | &apos;shadow&apos;*/ &#125;, formatter: function(params) &#123; var res = params[0]; return res.axisValue + &apos;&lt;/br&gt;&apos; + res.marker + res.seriesName + &apos;\t&apos; + res.value + &apos;%&apos;; &#125; &#125;, grid: &#123; left: &apos;3%&apos;, bottom: &apos;50px&apos;, containLabel: true, height: &apos;450px&apos; &#125;, xAxis : [ &#123; type : &apos;category&apos;, data : [&apos;玄武区&apos;, &apos;秦淮区&apos;, &apos;鼓楼区&apos;, &apos;建邺区&apos;, &apos;栖霞区&apos;, &apos;雨花台区&apos;, &apos;浦口区&apos;,&apos;江宁区&apos;,&apos;六合区&apos;], axisTick: &#123; alignWithLabel: true &#125; &#125; ], yAxis : [ &#123; type : &apos;value&apos;, axisLabel: &#123; formatter: &apos;&#123;value&#125; %&apos; &#125; &#125; ], series : [ &#123; type:&apos;bar&apos;, name:&apos;巡河完成率&apos;, barWidth: &apos;40%&apos;, label: &#123; normal: &#123; show: true, position: &apos;inside&apos;, formatter: &apos;&#123;c&#125;%&apos; &#125; &#125;, itemStyle: &#123; normal:&#123; color: &apos;#3399ff&apos; &#125; &#125;, data: data &#125; ]&#125;; riverRateB.setOption(option);]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git配置ssh]]></title>
    <url>%2F2019%2F09%2F08%2Fgit%2Fgit%E9%85%8D%E7%BD%AEssh%2F</url>
    <content type="text"><![CDATA[一. 在Linux或macOS上打开终端，或在Windows上打开Git Bash / WSL。二. 生成新的ED25519 SSH密钥对：1ssh-keygen -t ed25519 -C &quot;email@example.com&quot;或者，如果你想使用RSA：1ssh-keygen -o -t rsa -b 4096 -C &quot;email@example.com&quot; 该-C标志在键中添加注释，以防你有多个注释，并想知道哪个是哪个。这是可选的。 三. 接下来，系统将提示你输入文件路径以保存SSH密钥对。如果你还没有SSH密钥对且未生成部署密钥，请按下建议的路径 Enter。使用建议的路径通常允许SSH客户端自动使用SSH密钥对而无需其他配置。如果你已经拥有一个带有建议文件路径的SSH密钥对，则需要输入一个新的文件路径并声明该SSH密钥对将在你的~/.ssh/config文件中用于哪个主机密钥对。 四. 确定路径后，系统将提示你输入密码以保护新的SSH密钥对。这是使用密码的最佳做法，但这不是必需的，你可以通过按Enter两次跳过创建密码== 。在任何情况下，如果要添加或更改SSH密钥对的密码，可以使用以下-p标志：ssh-keygen -p -o -f 五. 温馨提示如果不想clone、拉取、提交时输入密码，那么生成密钥的时候就不要输入密码 原文如下 12345&lt;html&gt;&lt;div class=&quot;documentation md prepend-top-default&quot;&gt;&lt;h1 data-sourcepos=&quot;1:1-1:21&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-gitlab-and-ssh-keys&quot; class=&quot;anchor&quot; href=&quot;#gitlab-and-ssh-keys&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;GitLab and SSH keys&lt;/h1&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;3:1-6:64&quot; dir=&quot;auto&quot;&gt;Git is a distributed version control system, which means you can work locally&amp;#x000A;but you can also share or &quot;push&quot; your changes to other servers.&amp;#x000A;Before you can push your changes to a GitLab server&amp;#x000A;you need a secure communication channel for sharing information.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;8:1-9:75&quot; dir=&quot;auto&quot;&gt;The SSH protocol provides this security and allows you to authenticate to the&amp;#x000A;GitLab remote server without supplying your username or password each time.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;11:1-12:143&quot; dir=&quot;auto&quot;&gt;For a more detailed explanation of how the SSH protocol works, read&amp;#x000A;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;this nice tutorial by DigitalOcean&lt;/a&gt;.&lt;/p&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;14:1-14:15&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-requirements&quot; class=&quot;anchor&quot; href=&quot;#requirements&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Requirements&lt;/h2&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;16:1-17:63&quot; dir=&quot;auto&quot;&gt;The only requirement is to have the OpenSSH client installed on your system. This&amp;#x000A;comes pre-installed on GNU/Linux and macOS, but not on Windows.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;19:1-20:9&quot; dir=&quot;auto&quot;&gt;Depending on your Windows version, there are different methods to work with&amp;#x000A;SSH keys.&lt;/p&gt;&amp;#x000A;&lt;h3 data-sourcepos=&quot;22:1-22:43&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-windows-10-windows-subsystem-for-linux&quot; class=&quot;anchor&quot; href=&quot;#windows-10-windows-subsystem-for-linux&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Windows 10: Windows Subsystem for Linux&lt;/h3&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;24:1-28:25&quot; dir=&quot;auto&quot;&gt;Starting with Windows 10, you can&amp;#x000A;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/wsl/install-win10&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;install the Windows Subsystem for Linux (WSL)&lt;/a&gt;&amp;#x000A;where you can run Linux distributions directly on Windows, without the overhead&amp;#x000A;of a virtual machine. Once installed and set up, you&apos;ll have the Git and SSH&amp;#x000A;clients at your disposal.&lt;/p&gt;&amp;#x000A;&lt;h3 data-sourcepos=&quot;30:1-30:43&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-windows-10-81-and-7-git-for-windows&quot; class=&quot;anchor&quot; href=&quot;#windows-10-81-and-7-git-for-windows&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Windows 10, 8.1, and 7: Git for Windows&lt;/h3&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;32:1-35:77&quot; dir=&quot;auto&quot;&gt;The easiest way to install Git and the SSH client on Windows 8.1 and Windows 7&amp;#x000A;is &lt;a href=&quot;https://gitforwindows.org&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;Git for Windows&lt;/a&gt;. It provides a Bash&amp;#x000A;emulation (Git Bash) used for running Git from the command line and the&amp;#x000A;&lt;code&gt;ssh-keygen&lt;/code&gt; command that is useful to create SSH keys as you&apos;ll learn below.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;37:1-42:140&quot; dir=&quot;auto&quot;&gt;NOTE: &lt;strong&gt;Alternative tools:&lt;/strong&gt;&amp;#x000A;Although not explored in this page, you can use some alternative tools.&amp;#x000A;&lt;a href=&quot;https://www.cygwin.com&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;Cygwin&lt;/a&gt; is a large collection of GNU and open source&amp;#x000A;tools which provide functionality similar to a Unix distribution.&amp;#x000A;&lt;a href=&quot;https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;PuttyGen&lt;/a&gt;&amp;#x000A;provides a graphical user interface to &lt;a href=&quot;https://tartarus.org/~simon/putty-snapshots/htmldoc/Chapter8.html#pubkey-puttygen&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;create SSH keys&lt;/a&gt;.&lt;/p&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;44:1-44:40&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-types-of-ssh-keys-and-which-to-choose&quot; class=&quot;anchor&quot; href=&quot;#types-of-ssh-keys-and-which-to-choose&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Types of SSH keys and which to choose&lt;/h2&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;46:1-50:40&quot; dir=&quot;auto&quot;&gt;GitLab supports RSA, DSA, ECDSA, and ED25519 keys. Their difference lies on&amp;#x000A;the signing algorithm, and some of them have advantages over the others. For&amp;#x000A;more information, you can read this&amp;#x000A;&lt;a href=&quot;https://wiki.archlinux.org/index.php/SSH_keys#Choosing_the_authentication_key_type&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;nice article on ArchWiki&lt;/a&gt;.&amp;#x000A;We&apos;ll focus on ED25519 and RSA and here.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;52:1-55:69&quot; dir=&quot;auto&quot;&gt;NOTE: &lt;strong&gt;Note:&lt;/strong&gt;&amp;#x000A;As an admin, you can &lt;a href=&quot;../security/ssh_keys_restrictions.md&quot;&gt;restrict which keys should be permitted and their minimum length&lt;/a&gt;.&amp;#x000A;By default, all keys are permitted, which is also the case for&amp;#x000A;&lt;a href=&quot;../user/gitlab_com/index.md#ssh-host-keys-fingerprints&quot;&gt;GitLab.com&lt;/a&gt;.&lt;/p&gt;&amp;#x000A;&lt;h3 data-sourcepos=&quot;57:1-57:20&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-ed25519-ssh-keys&quot; class=&quot;anchor&quot; href=&quot;#ed25519-ssh-keys&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;ED25519 SSH keys&lt;/h3&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;59:1-61:65&quot; dir=&quot;auto&quot;&gt;Following &lt;a href=&quot;https://linux-audit.com/using-ed25519-openssh-keys-instead-of-dsa-rsa-ecdsa/&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;best practices&lt;/a&gt;,&amp;#x000A;you should always favor &lt;a href=&quot;https://ed25519.cr.yp.to/&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;ED25519&lt;/a&gt; SSH keys, since they&amp;#x000A;are more secure and have better performance over the other types.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;63:1-66:41&quot; dir=&quot;auto&quot;&gt;ED25519 SSH keys were introduced in OpenSSH 6.5,&amp;#x000A;so any modern OS should include the option to create them.&amp;#x000A;If for any reason your OS or the GitLab instance you interact with doesn&apos;t&amp;#x000A;support ED25519, you can fallback to RSA.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;68:1-70:109&quot; dir=&quot;auto&quot;&gt;NOTE: &lt;strong&gt;Note:&lt;/strong&gt;&amp;#x000A;Omnibus does not ship with OpenSSH, so it uses the version on your GitLab server. If using&amp;#x000A;Omnibus, ensure the version of OpenSSH installed is version 6.5 or newer if you want to use ED25519 SSH keys.&lt;/p&gt;&amp;#x000A;&lt;h3 data-sourcepos=&quot;72:1-72:16&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-rsa-ssh-keys&quot; class=&quot;anchor&quot; href=&quot;#rsa-ssh-keys&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;RSA SSH keys&lt;/h3&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;74:1-76:31&quot; dir=&quot;auto&quot;&gt;RSA keys are the most common ones and therefore the most compatible with&amp;#x000A;servers that may have an old OpenSSH version. Use them if the GitLab server&amp;#x000A;doesn&apos;t work with ED25519 keys.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;78:1-80:8&quot; dir=&quot;auto&quot;&gt;The minimum key size is 1024 bits, defaulting to 2048. If you wish to generate a&amp;#x000A;stronger RSA key pair, specify the &lt;code&gt;-b&lt;/code&gt; flag with a higher bit value than the&amp;#x000A;default.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;82:1-86:14&quot; dir=&quot;auto&quot;&gt;The old, default password encoding for SSH private keys is&amp;#x000A;&lt;a href=&quot;https://latacora.singles/2018/08/03/the-default-openssh.html&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;insecure&lt;/a&gt;;&amp;#x000A;it&apos;s only a single round of an MD5 hash. Since OpenSSH version 6.5, you should&amp;#x000A;use the &lt;code&gt;-o&lt;/code&gt; option to &lt;code&gt;ssh-keygen&lt;/code&gt; to encode your private key in a new, more&amp;#x000A;secure format.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;88:1-90:19&quot; dir=&quot;auto&quot;&gt;If you already have an RSA SSH key pair to use with GitLab, consider upgrading it&amp;#x000A;to use the more secure password encryption format by using the following command&amp;#x000A;on the private key:&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight shell&quot; lang=&quot;shell&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;shell&quot;&gt;ssh-keygen &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; ~/.ssh/id_rsa&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;96:1-96:32&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-generating-a-new-ssh-key-pair&quot; class=&quot;anchor&quot; href=&quot;#generating-a-new-ssh-key-pair&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Generating a new SSH key pair&lt;/h2&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;98:1-99:66&quot; dir=&quot;auto&quot;&gt;Before creating an SSH key pair, make sure to understand the&amp;#x000A;&lt;a href=&quot;#types-of-ssh-keys-and-which-to-choose&quot;&gt;different types of keys&lt;/a&gt;.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;101:1-101:29&quot; dir=&quot;auto&quot;&gt;To create a new SSH key pair:&lt;/p&gt;&amp;#x000A;&lt;ol data-sourcepos=&quot;103:1-140:0&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;103:1-103:67&quot;&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;103:4-103:67&quot;&gt;Open a terminal on Linux or macOS, or Git Bash / WSL on Windows.&lt;/p&gt;&amp;#x000A;&lt;/li&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;104:1-118:0&quot;&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;104:4-104:39&quot;&gt;Generate a new ED25519 SSH key pair:&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight shell&quot; lang=&quot;shell&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;shell&quot;&gt;ssh-keygen &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; ed25519 &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;email@example.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;110:4-110:30&quot;&gt;Or, if you want to use RSA:&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight shell&quot; lang=&quot;shell&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;shell&quot;&gt;ssh-keygen &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; rsa &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; 4096 &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;email@example.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;116:4-117:51&quot;&gt;The &lt;code&gt;-C&lt;/code&gt; flag adds a comment in the key in case you have multiple of them&amp;#x000A;and want to tell which is which. It is optional.&lt;/p&gt;&amp;#x000A;&lt;/li&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;119:1-128:0&quot;&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;119:4-123:74&quot;&gt;Next, you will be prompted to input a file path to save your SSH key pair to.&amp;#x000A;If you don&apos;t already have an SSH key pair and aren&apos;t generating a &lt;a href=&quot;#deploy-keys&quot;&gt;deploy key&lt;/a&gt;,&amp;#x000A;use the suggested path by pressing&amp;#x000A;&lt;kbd&gt;Enter&lt;/kbd&gt;. Using the suggested path will normally allow your SSH client&amp;#x000A;to automatically use the SSH key pair with no additional configuration.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;125:4-127:67&quot;&gt;If you already have an SSH key pair with the suggested file path, you will need&amp;#x000A;to input a new file path and &lt;a href=&quot;#working-with-non-default-ssh-key-pair-paths&quot;&gt;declare what host&lt;/a&gt;&amp;#x000A;this SSH key pair will be used for in your &lt;code&gt;~/.ssh/config&lt;/code&gt; file.&lt;/p&gt;&amp;#x000A;&lt;/li&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;129:1-140:0&quot;&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;129:4-132:26&quot;&gt;Once the path is decided, you will be prompted to input a password to&amp;#x000A;secure your new SSH key pair. It&apos;s a best practice to use a password,&amp;#x000A;but it&apos;s not required and you can skip creating it by pressing&amp;#x000A;&lt;kbd&gt;Enter&lt;/kbd&gt; twice.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;134:4-135:29&quot;&gt;If, in any case, you want to add or change the password of your SSH key pair,&amp;#x000A;you can use the &lt;code&gt;-p&lt;/code&gt; flag:&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight plaintext&quot; lang=&quot;plaintext&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt;ssh-keygen -p -o -f &amp;lt;keyname&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;/li&gt;&amp;#x000A;&lt;/ol&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;141:1-141:74&quot; dir=&quot;auto&quot;&gt;Now, it&apos;s time to add the newly created public key to your GitLab account.&lt;/p&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;143:1-143:43&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-adding-an-ssh-key-to-your-gitlab-account&quot; class=&quot;anchor&quot; href=&quot;#adding-an-ssh-key-to-your-gitlab-account&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Adding an SSH key to your GitLab account&lt;/h2&gt;&amp;#x000A;&lt;ol data-sourcepos=&quot;145:1-182:0&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;145:1-171:0&quot;&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;145:4-146:38&quot;&gt;Copy your &lt;strong&gt;public&lt;/strong&gt; SSH key to the clipboard by using one of the commands below&amp;#x000A;depending on your Operating System:&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;148:4-148:13&quot;&gt;&lt;strong&gt;macOS:&lt;/strong&gt;&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight shell&quot; lang=&quot;shell&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;shell&quot;&gt;pbcopy &amp;lt; ~/.ssh/id_ed25519.pub&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;154:4-154:52&quot;&gt;&lt;strong&gt;WSL / GNU/Linux (requires the xclip package):&lt;/strong&gt;&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight shell&quot; lang=&quot;shell&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;shell&quot;&gt;xclip &lt;span class=&quot;nt&quot;&gt;-sel&lt;/span&gt; clip &amp;lt; ~/.ssh/id_ed25519.pub&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;160:4-160:27&quot;&gt;&lt;strong&gt;Git Bash on Windows:&lt;/strong&gt;&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight shell&quot; lang=&quot;shell&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;shell&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; ~/.ssh/id_ed25519.pub | clip&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;166:4-167:54&quot;&gt;You can also open the key in a graphical editor and copy it from there,&amp;#x000A;but be careful not to accidentally change anything.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;169:4-170:60&quot;&gt;NOTE: &lt;strong&gt;Note:&lt;/strong&gt;&amp;#x000A;If you opted to create an RSA key, the name might differ.&lt;/p&gt;&amp;#x000A;&lt;/li&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;172:1-182:0&quot;&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;172:4-172:57&quot;&gt;Add your &lt;strong&gt;public&lt;/strong&gt; SSH key to your GitLab account by:&lt;/p&gt;&amp;#x000A;&lt;ol data-sourcepos=&quot;173:4-178:0&quot;&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;173:4-173:80&quot;&gt;Clicking your avatar in the upper right corner and selecting &lt;strong&gt;Settings&lt;/strong&gt;.&lt;/li&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;174:4-176:120&quot;&gt;Navigating to &lt;strong&gt;SSH Keys&lt;/strong&gt; and pasting your &lt;strong&gt;public&lt;/strong&gt; key in the &lt;strong&gt;Key&lt;/strong&gt; field. If you:&amp;#x000A;&lt;ul data-sourcepos=&quot;175:7-176:120&quot;&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;175:7-175:80&quot;&gt;Created the key with a comment, this will appear in the &lt;strong&gt;Title&lt;/strong&gt; field.&lt;/li&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;176:7-176:120&quot;&gt;Created the key without a comment, give your key an identifiable title like &lt;em&gt;Work Laptop&lt;/em&gt; or &lt;em&gt;Home Workstation&lt;/em&gt;.&lt;/li&gt;&amp;#x000A;&lt;/ul&gt;&amp;#x000A;&lt;/li&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;177:4-178:0&quot;&gt;Click the &lt;strong&gt;Add key&lt;/strong&gt; button.&lt;/li&gt;&amp;#x000A;&lt;/ol&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;179:4-181:77&quot;&gt;NOTE: &lt;strong&gt;Note:&lt;/strong&gt;&amp;#x000A;If you manually copied your public SSH key make sure you copied the entire&amp;#x000A;key starting with &lt;code&gt;ssh-ed25519&lt;/code&gt; (or &lt;code&gt;ssh-rsa&lt;/code&gt;) and ending with your email.&lt;/p&gt;&amp;#x000A;&lt;/li&gt;&amp;#x000A;&lt;/ol&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;183:1-183:46&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-testing-that-everything-is-set-up-correctly&quot; class=&quot;anchor&quot; href=&quot;#testing-that-everything-is-set-up-correctly&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Testing that everything is set up correctly&lt;/h2&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;185:1-186:74&quot; dir=&quot;auto&quot;&gt;To test whether your SSH key was added correctly, run the following command in&amp;#x000A;your terminal (replacing &lt;code&gt;gitlab.com&lt;/code&gt; with your GitLab&apos;s instance domain):&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight shell&quot; lang=&quot;shell&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;shell&quot;&gt;ssh &lt;span class=&quot;nt&quot;&gt;-T&lt;/span&gt; git@gitlab.com&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;192:1-195:26&quot; dir=&quot;auto&quot;&gt;The first time you connect to GitLab via SSH, you will be asked to verify the&amp;#x000A;authenticity of the GitLab host you are connecting to.&amp;#x000A;For example, when connecting to GitLab.com, answer &lt;code&gt;yes&lt;/code&gt; to add GitLab.com to&amp;#x000A;the list of trusted hosts:&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight plaintext&quot; lang=&quot;plaintext&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt;The authenticity of host &apos;gitlab.com (35.231.145.151)&apos; can&apos;t be established.&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC2&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt;ECDSA key fingerprint is SHA256:HbW3g8zUjNSksFbqTiUWPWg2Bq1x8xdGUrliXFzSnUw.&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC3&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt;Are you sure you want to continue connecting (yes/no)? yes&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC4&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt;Warning: Permanently added &apos;gitlab.com&apos; (ECDSA) to the list of known hosts.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;204:1-207:53&quot; dir=&quot;auto&quot;&gt;NOTE: &lt;strong&gt;Note:&lt;/strong&gt;&amp;#x000A;For GitLab.com, consult the&amp;#x000A;&lt;a href=&quot;../user/gitlab_com/index.md#ssh-host-keys-fingerprints&quot;&gt;SSH host keys fingerprints&lt;/a&gt;,&amp;#x000A;to make sure you&apos;re connecting to the correct server.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;209:1-211:68&quot; dir=&quot;auto&quot;&gt;Once added to the list of known hosts, you won&apos;t be asked to validate the&amp;#x000A;authenticity of GitLab&apos;s host again. Run the above command once more, and&amp;#x000A;you should only receive a &lt;em&gt;Welcome to GitLab, &lt;code&gt;@username&lt;/code&gt;!&lt;/em&gt; message.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;213:1-214:46&quot; dir=&quot;auto&quot;&gt;If the welcome message doesn&apos;t appear, run SSH&apos;s verbose mode by replacing &lt;code&gt;-T&lt;/code&gt;&amp;#x000A;with &lt;code&gt;-vvvT&lt;/code&gt; to understand where the error is.&lt;/p&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;216:1-216:46&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-working-with-non-default-ssh-key-pair-paths&quot; class=&quot;anchor&quot; href=&quot;#working-with-non-default-ssh-key-pair-paths&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Working with non-default SSH key pair paths&lt;/h2&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;218:1-220:26&quot; dir=&quot;auto&quot;&gt;If you used a non-default file path for your GitLab SSH key pair,&amp;#x000A;you must configure your SSH client to find your GitLab private SSH key&amp;#x000A;for connections to GitLab.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;222:1-223:53&quot; dir=&quot;auto&quot;&gt;Open a terminal and use the following commands&amp;#x000A;(replacing &lt;code&gt;other_id_rsa&lt;/code&gt; with your private SSH key):&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight shell&quot; lang=&quot;shell&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;shell&quot;&gt;&lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;ssh-agent &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC2&quot; class=&quot;line&quot; lang=&quot;shell&quot;&gt;ssh-add ~/.ssh/other_id_rsa&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;230:1-233:44&quot; dir=&quot;auto&quot;&gt;To retain these settings, you&apos;ll need to save them to a configuration file.&amp;#x000A;For OpenSSH clients this is configured in the &lt;code&gt;~/.ssh/config&lt;/code&gt; file. In this&amp;#x000A;file you can set up configurations for multiple hosts, like GitLab.com, your&amp;#x000A;own GitLab instance, GitHub, Bitbucket, etc.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;235:1-235:66&quot; dir=&quot;auto&quot;&gt;Below are two example host configurations using their own SSH key:&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight conf&quot; lang=&quot;conf&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;conf&quot;&gt;&lt;span class=&quot;c&quot;&gt;# GitLab.com&lt;/span&gt;&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC2&quot; class=&quot;line&quot; lang=&quot;conf&quot;&gt;&lt;span class=&quot;n&quot;&gt;Host&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gitlab&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC3&quot; class=&quot;line&quot; lang=&quot;conf&quot;&gt; &lt;span class=&quot;n&quot;&gt;Preferredauthentications&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;publickey&lt;/span&gt;&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC4&quot; class=&quot;line&quot; lang=&quot;conf&quot;&gt; &lt;span class=&quot;n&quot;&gt;IdentityFile&lt;/span&gt; ~/.&lt;span class=&quot;n&quot;&gt;ssh&lt;/span&gt;/&lt;span class=&quot;n&quot;&gt;gitlab_com_rsa&lt;/span&gt;&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC5&quot; class=&quot;line&quot; lang=&quot;conf&quot;&gt;&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC6&quot; class=&quot;line&quot; lang=&quot;conf&quot;&gt;&lt;span class=&quot;c&quot;&gt;# Private GitLab instance&lt;/span&gt;&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC7&quot; class=&quot;line&quot; lang=&quot;conf&quot;&gt;&lt;span class=&quot;n&quot;&gt;Host&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gitlab&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;company&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC8&quot; class=&quot;line&quot; lang=&quot;conf&quot;&gt; &lt;span class=&quot;n&quot;&gt;Preferredauthentications&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;publickey&lt;/span&gt;&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC9&quot; class=&quot;line&quot; lang=&quot;conf&quot;&gt; &lt;span class=&quot;n&quot;&gt;IdentityFile&lt;/span&gt; ~/.&lt;span class=&quot;n&quot;&gt;ssh&lt;/span&gt;/&lt;span class=&quot;n&quot;&gt;example_com_rsa&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;249:1-251:53&quot; dir=&quot;auto&quot;&gt;Public SSH keys need to be unique to GitLab, as they will bind to your account.&amp;#x000A;Your SSH key is the only identifier you&apos;ll have when pushing code via SSH,&amp;#x000A;that&apos;s why it needs to uniquely map to a single user.&lt;/p&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;253:1-253:26&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-per-repository-ssh-keys&quot; class=&quot;anchor&quot; href=&quot;#per-repository-ssh-keys&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Per-repository SSH keys&lt;/h2&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;255:1-256:69&quot; dir=&quot;auto&quot;&gt;If you want to use different keys depending on the repository you are working&amp;#x000A;on, you can issue the following command while inside your repository:&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight shell&quot; lang=&quot;shell&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;shell&quot;&gt;git config core.sshCommand &lt;span class=&quot;s2&quot;&gt;&quot;ssh -o IdentitiesOnly=yes -i ~/.ssh/private-key-filename-for-this-repository -F /dev/null&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;262:1-262:63&quot; dir=&quot;auto&quot;&gt;This will not use the SSH Agent and requires at least Git 2.10.&lt;/p&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;264:1-264:14&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-deploy-keys&quot; class=&quot;anchor&quot; href=&quot;#deploy-keys&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Deploy keys&lt;/h2&gt;&amp;#x000A;&lt;h3 data-sourcepos=&quot;266:1-266:30&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-per-repository-deploy-keys&quot; class=&quot;anchor&quot; href=&quot;#per-repository-deploy-keys&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Per-repository deploy keys&lt;/h3&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;268:1-269:45&quot; dir=&quot;auto&quot;&gt;Deploy keys allow read-only or read-write (if enabled) access to one or&amp;#x000A;multiple projects with a single SSH key pair.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;271:1-273:19&quot; dir=&quot;auto&quot;&gt;This is really useful for cloning repositories to your Continuous&amp;#x000A;Integration (CI) server. By using deploy keys, you don&apos;t have to set up a&amp;#x000A;dummy user account.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;275:1-280:22&quot; dir=&quot;auto&quot;&gt;If you are a project maintainer or owner, you can add a deploy key in the&amp;#x000A;project&apos;s &lt;strong&gt;Settings &amp;gt; Repository&lt;/strong&gt; page by expanding the&amp;#x000A;&lt;strong&gt;Deploy Keys&lt;/strong&gt; section. Specify a title for the new&amp;#x000A;deploy key and paste a public SSH key. After this, the machine that uses&amp;#x000A;the corresponding private SSH key has read-only or read-write (if enabled)&amp;#x000A;access to the project.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;282:1-287:8&quot; dir=&quot;auto&quot;&gt;You can&apos;t add the same deploy key twice using the form.&amp;#x000A;If you want to add the same key to another project, please enable it in the&amp;#x000A;list that says &apos;Deploy keys from projects available to you&apos;. All the deploy&amp;#x000A;keys of all the projects you have access to are available. This project&amp;#x000A;access can happen through being a direct member of the project, or through&amp;#x000A;a group.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;289:1-290:8&quot; dir=&quot;auto&quot;&gt;Deploy keys can be shared between projects, you just need to add them to each&amp;#x000A;project.&lt;/p&gt;&amp;#x000A;&lt;h3 data-sourcepos=&quot;292:1-292:29&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-global-shared-deploy-keys&quot; class=&quot;anchor&quot; href=&quot;#global-shared-deploy-keys&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Global shared deploy keys&lt;/h3&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;294:1-295:66&quot; dir=&quot;auto&quot;&gt;Global Shared Deploy keys allow read-only or read-write (if enabled) access to&amp;#x000A;be configured on any repository in the entire GitLab installation.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;297:1-302:68&quot; dir=&quot;auto&quot;&gt;This is really useful for integrating repositories to secured, shared Continuous&amp;#x000A;Integration (CI) services or other shared services.&amp;#x000A;GitLab administrators can set up the Global Shared Deploy key in GitLab and&amp;#x000A;add the private key to any shared systems. Individual repositories opt into&amp;#x000A;exposing their repository using these keys when a project maintainers (or higher)&amp;#x000A;authorizes a Global Shared Deploy key to be used with their project.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;304:1-306:48&quot; dir=&quot;auto&quot;&gt;Global Shared Keys can provide greater security compared to Per-Project Deploy&amp;#x000A;Keys since an administrator of the target integrated system is the only one&amp;#x000A;who needs to know and configure the private key.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;308:1-316:17&quot; dir=&quot;auto&quot;&gt;GitLab administrators set up Global Deploy keys in the Admin area under the&amp;#x000A;section &lt;strong&gt;Deploy Keys&lt;/strong&gt;. Ensure keys have a meaningful title as that will be&amp;#x000A;the primary way for project maintainers and owners to identify the correct Global&amp;#x000A;Deploy key to add. For instance, if the key gives access to a SaaS CI instance,&amp;#x000A;use the name of that service in the key name if that is all it is used for.&amp;#x000A;When creating Global Shared Deploy keys, give some thought to the granularity&amp;#x000A;of keys - they could be of very narrow usage such as just a specific service or&amp;#x000A;of broader usage for something like &quot;Anywhere you need to give read access to&amp;#x000A;your repository&quot;.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;318:1-321:54&quot; dir=&quot;auto&quot;&gt;Once a GitLab administrator adds the Global Deployment key, project maintainers&amp;#x000A;and owners can add it in project&apos;s &lt;strong&gt;Settings &amp;gt; Repository&lt;/strong&gt; page by expanding the&amp;#x000A;&lt;strong&gt;Deploy Keys&lt;/strong&gt; section and clicking &lt;strong&gt;Enable&lt;/strong&gt; next to the appropriate key listed&amp;#x000A;under &lt;strong&gt;Public deploy keys available to any project&lt;/strong&gt;.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;323:1-325:54&quot; dir=&quot;auto&quot;&gt;NOTE: &lt;strong&gt;Note:&lt;/strong&gt;&amp;#x000A;The heading &lt;strong&gt;Public deploy keys available to any project&lt;/strong&gt; only appears&amp;#x000A;if there is at least one Global Deploy Key configured.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;327:1-331:55&quot; dir=&quot;auto&quot;&gt;CAUTION: &lt;strong&gt;Warning:&lt;/strong&gt;&amp;#x000A;Defining Global Deploy Keys does not expose any given repository via&amp;#x000A;the key until that repository adds the Global Deploy Key to their project.&amp;#x000A;In this way the Global Deploy Keys enable access by other systems, but do&amp;#x000A;not implicitly give any access just by setting them up.&lt;/p&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;333:1-333:15&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-applications&quot; class=&quot;anchor&quot; href=&quot;#applications&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Applications&lt;/h2&gt;&amp;#x000A;&lt;h3 data-sourcepos=&quot;335:1-335:11&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-eclipse&quot; class=&quot;anchor&quot; href=&quot;#eclipse&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Eclipse&lt;/h3&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;337:1-337:162&quot; dir=&quot;auto&quot;&gt;If you are using &lt;a href=&quot;https://www.eclipse.org/egit/&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;EGit&lt;/a&gt;, you can &lt;a href=&quot;https://wiki.eclipse.org/EGit/User_Guide#Eclipse_SSH_Configuration&quot; rel=&quot;nofollow noreferrer noopener&quot; target=&quot;_blank&quot;&gt;add your SSH key to Eclipse&lt;/a&gt;.&lt;/p&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;339:1-339:27&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-ssh-on-the-gitlab-server&quot; class=&quot;anchor&quot; href=&quot;#ssh-on-the-gitlab-server&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;SSH on the GitLab server&lt;/h2&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;341:1-344:18&quot; dir=&quot;auto&quot;&gt;GitLab integrates with the system-installed SSH daemon, designating a user&amp;#x000A;(typically named &lt;code&gt;git&lt;/code&gt;) through which all access requests are handled. Users&amp;#x000A;connecting to the GitLab server over SSH are identified by their SSH key instead&amp;#x000A;of their username.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;346:1-350:15&quot; dir=&quot;auto&quot;&gt;SSH &lt;em&gt;client&lt;/em&gt; operations performed on the GitLab server wil be executed as this&amp;#x000A;user. Although it is possible to modify the SSH configuration for this user to,&amp;#x000A;e.g., provide a private SSH key to authenticate these requests by, this practice&amp;#x000A;is &lt;strong&gt;not supported&lt;/strong&gt; and is strongly discouraged as it presents significant&amp;#x000A;security risks.&lt;/p&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;352:1-353:61&quot; dir=&quot;auto&quot;&gt;The GitLab check process includes a check for this condition, and will direct you&amp;#x000A;to this section if your server is configured like this, e.g.:&lt;/p&gt;&amp;#x000A;&lt;pre class=&quot;code highlight js-syntax-highlight plaintext&quot; lang=&quot;plaintext&quot; v-pre=&quot;true&quot;&gt;&lt;code&gt;&lt;span id=&quot;LC1&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt;$ gitlab-rake gitlab:check&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC2&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt;# ...&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC3&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt;Git user has default SSH configuration? ... no&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC4&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt; Try fixing it:&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC5&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt; mkdir ~/gitlab-check-backup-1504540051&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC6&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt; sudo mv /var/lib/git/.ssh/id_rsa ~/gitlab-check-backup-1504540051&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC7&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt; sudo mv /var/lib/git/.ssh/id_rsa.pub ~/gitlab-check-backup-1504540051&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC8&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt; For more information see:&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC9&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt; doc/ssh/README.md in section &quot;SSH on the GitLab server&quot;&lt;/span&gt;&amp;#x000A;&lt;span id=&quot;LC10&quot; class=&quot;line&quot; lang=&quot;plaintext&quot;&gt; Please fix the error above and rerun the checks.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;368:1-369:64&quot; dir=&quot;auto&quot;&gt;Remove the custom configuration as soon as you&apos;re able to. These customizations&amp;#x000A;are &lt;em&gt;explicitly not supported&lt;/em&gt; and may stop working at any time.&lt;/p&gt;&amp;#x000A;&lt;h2 data-sourcepos=&quot;371:1-371:18&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;a id=&quot;user-content-troubleshooting&quot; class=&quot;anchor&quot; href=&quot;#troubleshooting&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;Troubleshooting&lt;/h2&gt;&amp;#x000A;&lt;p data-sourcepos=&quot;373:1-374:39&quot; dir=&quot;auto&quot;&gt;If on Git clone you are prompted for a password like &lt;code&gt;git@gitlab.com&apos;s password:&lt;/code&gt;&amp;#x000A;something is wrong with your SSH setup.&lt;/p&gt;&amp;#x000A;&lt;ul data-sourcepos=&quot;376:1-381:51&quot; dir=&quot;auto&quot;&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;376:1-377:28&quot;&gt;Ensure that you generated your SSH key pair correctly and added the public SSH&amp;#x000A;key to your GitLab profile&lt;/li&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;378:1-379:26&quot;&gt;Try manually registering your private SSH key using &lt;code&gt;ssh-agent&lt;/code&gt; as documented&amp;#x000A;earlier in this document&lt;/li&gt;&amp;#x000A;&lt;li data-sourcepos=&quot;380:1-381:51&quot;&gt;Try to debug the connection by running &lt;code&gt;ssh -Tv git@example.com&lt;/code&gt;&amp;#x000A;(replacing &lt;code&gt;example.com&lt;/code&gt; with your GitLab domain)&lt;/li&gt;&amp;#x000A;&lt;/ul&gt;&lt;/div&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git推送本地项目到远程]]></title>
    <url>%2F2019%2F09%2F08%2Fgit%2Fgit%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[git推送本地项目到远程 在github新建一个分支项目名与本地项目名相同 在本地项目根目录下初始化一个仓库 1git init 将本地工程代码提交，git会为你在本地默认创建一个master分支： 12git add .git commit -m &quot;init project&quot; 将本地仓库关联远程仓库： 1git remote add origin &lt;GitHub项目地址&gt; 将本地代码推送到远程： 1git push -u origin master 这一步很可能会提示错误：fatal: refusing to merge unrelated histories 这是因为我们没有关联远程分枝master，需要使用操作： 1git pull origin master --allow-unrelated-histories 来允许pull未关联的历史记录。 最后推送代码到远程master分支： 1git push -u origin master 可能遇到的问题 error: RPC failed; curl 52 Empty reply from server 方法： git fetch origin –prune]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git忽略规则及.gitignore规则不生效的解决办法]]></title>
    <url>%2F2019%2F09%2F08%2Fgit%2Fgit%E5%BF%BD%E7%95%A5%E8%A7%84%E5%88%99%E5%8F%8A.gitignore%E8%A7%84%E5%88%99%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git忽略规则及.gitignore规则不生效的解决办法在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则。例如：1234567# 此为注释 – 将被 Git 忽略 *.a # 忽略所有 .a 结尾的文件!lib.a# 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/# 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交： 123git rm -r --cached .git add .git commit -m &apos;update .gitignore ```]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 常用命令]]></title>
    <url>%2F2019%2F09%2F08%2Fgit%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[提交一个文件夹下所有的文件 git add ‘文件夹’ git commit -m ‘描述’ git push –all 新建分支git branch ‘分支名’切换分支git checkout ‘分支名’新建并切换分支git checkout -b ‘分支名’拉取git pull 合并分支git merge ‘被合并的分支’ 删除本地分支git branch -d ‘分支名’ 删除远程分支git push origin [空格] [冒号] [需要删除的分支名字] eg: 删除远程中名为dev的分支 ==git push origin :dev== 回退到上一个版本git reset –hard HEAD^ 回退到指定版本git reset –hard 版本号(commit_id) 用git log可以查看提交历史，以便确定要回退到哪个版本。用git reflog查看命令历史，以便确定要回到未来的哪个版本。历史提交的记录git log –pretty=oneline –abbrev-commit git 推送某个分支到远程git push origin ‘分支名’ eg: 在dev上开发，推送到develop上 1234567git checkout dev......git add &apos;单个或多个修改&apos;git commit -m &apos;描述&apos;git checkout developgit merge --no-ff devgit push origin develop 本地有两个分支一个是develop一个是dev，在dev做了修改，执行add，commit，然切换分支到develop，执行merge到develop，最后push到远程，支持批操作 将远程git仓库里的指定分支拉取到本地（本地不存在的分支）git checkout -b 本地分支名 origin/远程分支名 stash储存用于将不想提交的文件暂存起来保存工作空间 git stash 查看所有暂存 git stash lish stash内容并不删除，你需要用git stash drop来删除； git stash apply git修改最近一次提交并且没有push到远程分支的message git commit –amend -m ‘修改的信息’ git commit –amend // 进入编辑模式， :w 或 按insert 键进行编辑，del键删除，esc键退出，:q 退出编辑界面 git 撤销上次commit git reset HEAD~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 创建回退到某个节点的新分支]]></title>
    <url>%2F2019%2F09%2F08%2Fgit%2Fgit%20%E5%88%9B%E5%BB%BA%E5%9B%9E%E9%80%80%E5%88%B0%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%96%B0%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[git 创建回退到某个节点的新分支123456789101112// 1.新建一个临时分支git checkout -b temp// 2.在临时分支上回退到某个版本git reset --hard &lt;版本号&gt;// 3.创建想要到分支名git checkout -b &lt;分支名&gt;// 4.将新建分支推送到远程仓库git push origin &lt;分支名&gt;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用命令]]></title>
    <url>%2F2019%2F09%2F08%2Flinux%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux 编辑保存文件命令123456789101112131415161718191、vi 和 vim 的两种工作模式命令模式：打开一个文件后的默认模式编辑模式：打开的文件键盘输入&quot;i&quot; 进入插入编辑模式，进行增删改操作的一个模式。2、键盘输入&quot;i&quot;进入编辑模式后，就可以进行编写文件了编写完怎么保存文件呢？1）先按“esc”键 退出编辑模式，切换到命令模式，然后输入以下命令就可以这些操作要保证是在命令模式下进行。2）保存并退出文件：&quot;:wq&quot;3) 如果只想保存文件 ：&quot;:w&quot;4）放弃所有文件修改：&quot;:q!&quot; 修改文件夹名1mv files1 files2 // 将files1重命名为files2 删除文件和文件夹12345678rm -rf 文件夹名 //删除文件夹 /** -r 就是向下递归，不管有多少级目录，一并删除 -f 就是直接强行删除，不作任何提示的意思*/rm -f 文件名 // 删除文件 回到根目录1cd ~]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang实践之路一]]></title>
    <url>%2F2018%2F08%2F11%2Fgo%2FGolang%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%E4%B8%80%2F</url>
    <content type="text"><![CDATA[go map[string]interface{}转map[string]string背景： 做一个上传历史架次的接口，这个接口中有很多个参数，由于本人刚开始学后端编程，不懂数据类型的概念，也不懂数据之间的转换关系，更不会怎么在golang中使用sql（哦！ 对了，sql也是作接口的时候才开始学习的），我接手的程序是用beego写的，所以我就照葫芦画瓢，想用 this.GetString(key string)的方式来做，要一个个取感觉好麻烦就想到了json字符串，这样只取一个，然后解析就好了，哈哈哈。想到这里就有了下面的代码 123456var result map[string]interface&#123;&#125;d := this.GetString(&quot;data&quot;)r := json.Unmarshal([]byte(string(d)), &amp;result)if r != nil &#123; panic(r)&#125; 就在我认为问题解决，跳支舞之后我测了一下，呵呵！sql跑出来的数据不对呀，一查表字段类型才发现，里面除了几个int64和int之外都是string类型，而interface会出错，所以就要类型转化，在models里面这样写 1234var list = map[string]stringfor k, v := range result &#123; list[k] = v.(string)&#125; 上面这种写法我觉得没错呀，可是程序一跑就报错 “Handler crashed with error assignment to entry in nil map” 什么鬼 – 处理程序在 nil map 中出现错误分配，哦，应该是内存出错，然后就到网上查了下，嗨，原来如此，把make给忘==来，来，；来，做一个修改== 12345list := make(map[string]string)for k, v := range result &#123; list[k] = v.(string)&#125; 欧耶！终于不报那个错误了 接着转换几个int64类型 12345678o := orm.NewOrm()droneid := list[&quot;droneid&quot;]starttimestr := list[&quot;starttime&quot;]endtimestr := list[&quot;endtime&quot;]abpointstr := list[&quot;abpoint&quot;]starttime, _ := strconv.ParseInt(starttimestr, 10, 64)endtime, _ := strconv.ParseInt(endtimestr, 10, 64)abpoint, _ := strconv.Atoi(abpointstr) 在sql中执行下 123456_, err = o.Raw(&quot;SELECT workid, are FROM dronepos WHERE droneid=? and workid&gt; ? and workid&lt; ? order by workid desc limit 1&quot;, droneid, starttime, endtime).Values(&amp;data)_, err := o.Raw(&quot;UPDATE dronepos SET pesticides=?, are=? WHERE workid=?&quot;, list[&quot;pesticides&quot;], list[&quot;are&quot;], workid).Exec()_, err = o.Raw(&quot;INSERT INTO dronepos (workid,droneid,path,isarmpath,isbumppath,starttime,worktime,are,modes,tele,voltage,gps,compass,land,arm,drug,bump,battery,pitch,roll,yaw,alt,ground,longtime,abpoint,iotid,iotname,iotversion,fcversion,pesticides) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)&quot;, starttime, list[&quot;droneid&quot;], list[&quot;path&quot;], list[&quot;isarmpath&quot;], list[&quot;isbumppath&quot;], starttime, endtime, list[&quot;are&quot;], list[&quot;modes&quot;], list[&quot;tele&quot;], list[&quot;voltage&quot;], list[&quot;gps&quot;], list[&quot;compass&quot;], list[&quot;land&quot;], list[&quot;arm&quot;], list[&quot;drug&quot;], list[&quot;bump&quot;], list[&quot;battery&quot;], list[&quot;pitch&quot;], list[&quot;roll&quot;], list[&quot;yaw&quot;], list[&quot;alt&quot;], list[&quot;ground&quot;], list[&quot;longtime&quot;], abpoint, list[&quot;iotid&quot;], list[&quot;iotname&quot;], list[&quot;iotversion&quot;], list[&quot;fcversion&quot;], list[&quot;pesticides&quot;]).Exec() MD 刚开始就让老子写这么长的sql（_ ：_） 贴出完整代码 1234567891011121314151617181920212223242526272829303132333435363738func ApiDronesPosDeal(result map[string]interface&#123;&#125;) (err error) &#123; list := make(map[string]string) for k, v := range result &#123; list[k] = v.(string) &#125; o := orm.NewOrm() droneid := list[&quot;droneid&quot;] starttimestr := list[&quot;starttime&quot;] endtimestr := list[&quot;endtime&quot;] abpointstr := list[&quot;abpoint&quot;] starttime, _ := strconv.ParseInt(starttimestr, 10, 64) endtime, _ := strconv.ParseInt(endtimestr, 10, 64) abpoint, _ := strconv.Atoi(abpointstr) var data []orm.Params _, err = o.Raw(&quot;SELECT workid, are FROM dronepos WHERE droneid=? and workid&gt; ? and workid&lt; ? order by workid desc limit 1&quot;, droneid, starttime, endtime).Values(&amp;data) if err != nil &#123; return err &#125; fmt.Printf(&quot;len:%v\n data:%v\n&quot;, len(data), data) if len(data) != 0 &#123; print(&quot;update&quot;) workid := data[0][&quot;workid&quot;] are := data[0][&quot;are&quot;] // 有数据--&gt;跟新面积、用药量 if are == &quot;0&quot; &#123; _, err := o.Raw(&quot;UPDATE dronepos SET pesticides=?, are=? WHERE workid=?&quot;, list[&quot;pesticides&quot;], list[&quot;are&quot;], workid).Exec() return err &#125; else &#123; _, err := o.Raw(&quot;UPDATE dronepos SET pesticides=? WHERE workid=?&quot;, list[&quot;pesticides&quot;], workid).Exec() return err &#125; &#125; else &#123; print(&quot;insert&quot;) //没有数据--&gt;插入一条 _, err = o.Raw(&quot;INSERT INTO dronepos (workid,droneid,path,isarmpath,isbumppath,starttime,worktime,are,modes,tele,voltage,gps,compass,land,arm,drug,bump,battery,pitch,roll,yaw,alt,ground,longtime,abpoint,iotid,iotname,iotversion,fcversion,pesticides) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)&quot;, starttime, list[&quot;droneid&quot;], list[&quot;path&quot;], list[&quot;isarmpath&quot;], list[&quot;isbumppath&quot;], starttime, endtime, list[&quot;are&quot;], list[&quot;modes&quot;], list[&quot;tele&quot;], list[&quot;voltage&quot;], list[&quot;gps&quot;], list[&quot;compass&quot;], list[&quot;land&quot;], list[&quot;arm&quot;], list[&quot;drug&quot;], list[&quot;bump&quot;], list[&quot;battery&quot;], list[&quot;pitch&quot;], list[&quot;roll&quot;], list[&quot;yaw&quot;], list[&quot;alt&quot;], list[&quot;ground&quot;], list[&quot;longtime&quot;], abpoint, list[&quot;iotid&quot;], list[&quot;iotname&quot;], list[&quot;iotversion&quot;], list[&quot;fcversion&quot;], list[&quot;pesticides&quot;]).Exec() &#125; return err&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
