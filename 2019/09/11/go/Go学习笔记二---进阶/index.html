<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.jpg?v=7.4.0">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="方法和接口方法Go 没有类。不过你可以为结构体类型定义方法。方法就是一类带特殊的 接收者 参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。在此例中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者。123456789101112131415161718192021package mainimport (	&amp;quot;fmt&amp;quot;	&amp;quot;mat">
<meta name="keywords" content="Go">
<meta property="og:type" content="article">
<meta property="og:title" content="Go学习笔记二---进阶">
<meta property="og:url" content="haidaoge.github.io/2019/09/11/go/Go学习笔记二---进阶/index.html">
<meta property="og:site_name" content="haidaoge 的日志">
<meta property="og:description" content="方法和接口方法Go 没有类。不过你可以为结构体类型定义方法。方法就是一类带特殊的 接收者 参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。在此例中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者。123456789101112131415161718192021package mainimport (	&amp;quot;fmt&amp;quot;	&amp;quot;mat">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-09-11T15:37:54.229Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go学习笔记二---进阶">
<meta name="twitter:description" content="方法和接口方法Go 没有类。不过你可以为结构体类型定义方法。方法就是一类带特殊的 接收者 参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。在此例中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者。123456789101112131415161718192021package mainimport (	&amp;quot;fmt&amp;quot;	&amp;quot;mat">
  <link rel="canonical" href="haidaoge.github.io/2019/09/11/go/Go学习笔记二---进阶/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Go学习笔记二---进阶 | haidaoge 的日志</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">haidaoge 的日志</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a class="book-mark-link book-mark-link-fixed" href="#"></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="haidaoge.github.io/2019/09/11/go/Go学习笔记二---进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haidaoge">
      <meta itemprop="description" content="haidaoge 的日志">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haidaoge 的日志">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Go学习笔记二---进阶

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-11 23:37:42 / 修改时间：23:37:54" itemprop="dateCreated datePublished" datetime="2019-09-11T23:37:42+08:00">2019-09-11</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Go 没有类。不过你可以为结构体类型定义方法。</p><p>方法就是一类带特殊的 接收者 参数的函数。</p><p>方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。</p><p>在此例中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">	X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v Vertex) Abs() float64 &#123;</span><br><span class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	v := Vertex&#123;3, 4&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 5*/</span><br></pre></td></tr></table></figure><a id="more"></a>





<h3 id="方法即函数"><a href="#方法即函数" class="headerlink" title="方法即函数"></a>方法即函数</h3><p>记住：方法只是个带接收者参数的函数。</p>
<p>现在这个 Abs 的写法就是个正常的函数，功能并没有什么变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">	X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Abs(v Vertex) float64 &#123;</span><br><span class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	v := Vertex&#123;3, 4&#125;</span><br><span class="line">	fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//5</span><br></pre></td></tr></table></figure>

<h3 id="非结构体类型"><a href="#非结构体类型" class="headerlink" title="非结构体类型"></a>非结构体类型</h3><p>你也可以为非结构体类型声明方法。</p>
<p>在此例中，我们看到了一个带 Abs 方法的数值类型 MyFloat。</p>
<p>你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。</p>
<p>（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type MyFloat float64</span><br><span class="line"></span><br><span class="line">func (f MyFloat) Abs() float64 &#123;</span><br><span class="line">	if f &lt; 0 &#123;</span><br><span class="line">		return float64(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	return float64(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f := MyFloat(-math.Sqrt2)</span><br><span class="line">	fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br><span class="line">//1.4142135623730951</span><br></pre></td></tr></table></figure>

<h3 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h3><p>你可以为指针接收者声明方法。</p>
<p>这意味着对于某类型 T，接收者的类型可以用 *T 的文法。（此外，T 不能是像 *int 这样的指针。）</p>
<p>例如，这里为 *Vertex 定义了 Scale 方法。</p>
<p>指针接收者的方法可以修改接收者指向的值（就像 Scale 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p>
<p>试着移除第 16 行 Scale 函数声明中的 *，观察此程序的行为如何变化。</p>
<p>若使用值接收者，那么 Scale 方法会对原始 Vertex 值的副本进行操作。（对于函数的其它参数也是如此。）Scale 方法必须用指针接受者来更改 main 函数中声明的 Vertex 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">	X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v Vertex) Abs() float64 &#123;</span><br><span class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Scale(f float64) float64 &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">	return v.X + v.Y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	v := Vertex&#123;3, 4&#125;</span><br><span class="line">	m := v.Scale(10)</span><br><span class="line">	fmt.Println(v.Abs(),m)</span><br><span class="line">&#125;</span><br><span class="line">// 50, 70</span><br></pre></td></tr></table></figure>

<p>去掉*</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">	X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v Vertex) Abs() float64 &#123;</span><br><span class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v Vertex) Scale(f float64) float64 &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">	return v.X + v.Y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	v := Vertex&#123;3, 4&#125;</span><br><span class="line">	m := v.Scale(10)</span><br><span class="line">	fmt.Println(v.Abs(),m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5, 70</span><br></pre></td></tr></table></figure>

<p>综上所述，指针接收者类似js中object的方法，值接收者类似js中的函数，方法在于可以改变object中的属性值，函数不能修改object中属性值</p>
<h3 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h3><p>比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：</p>
<p>var v Vertex<br>ScaleFunc(v, 5)  // 编译错误！<br>ScaleFunc(&amp;v, 5) // OK<br>而以指针为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<p>var v Vertex<br>v.Scale(5)  // OK<br>p := &amp;v<br>p.Scale(10) // OK<br>对于语句 v.Scale(5)，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">	X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Scale(f float64) &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ScaleFunc(v *Vertex, f float64) &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	v := Vertex&#123;3, 4&#125;</span><br><span class="line">	v.Scale(2)</span><br><span class="line">	ScaleFunc(&amp;v, 10)</span><br><span class="line"></span><br><span class="line">	p := &amp;Vertex&#123;4, 3&#125;</span><br><span class="line">	p.Scale(3)</span><br><span class="line">	ScaleFunc(p, 8)</span><br><span class="line">	</span><br><span class="line">	fmt.Println(v, p)   // &#123;60 80&#125; &amp;&#123;96 72&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(v, *p) // &#123;60 80&#125; &#123;96 72&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的事情也发生在相反的方向。</p>
<p>接受一个值作为参数的函数必须接受一个指定类型的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">fmt.Println(AbsFunc(v))  // OK</span><br><span class="line">fmt.Println(AbsFunc(&amp;v)) // 编译错误！</span><br></pre></td></tr></table></figure>

<p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">fmt.Println(v.Abs()) // OK</span><br><span class="line">p := &amp;v</span><br><span class="line">fmt.Println(p.Abs()) // OK</span><br></pre></td></tr></table></figure>

<p>这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">	X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v Vertex) Abs() float64 &#123;</span><br><span class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func AbsFunc(v Vertex) float64 &#123;</span><br><span class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	v := Vertex&#123;3, 4&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">	fmt.Println(AbsFunc(v))</span><br><span class="line"></span><br><span class="line">	p := &amp;Vertex&#123;4, 3&#125;</span><br><span class="line">	fmt.Println(p.Abs())</span><br><span class="line">	fmt.Println(AbsFunc(*p))</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    5</span><br><span class="line">    5</span><br><span class="line">    5</span><br><span class="line">    5</span><br><span class="line">    */</span><br></pre></td></tr></table></figure>

<p>注意 </p>
<blockquote>
<p>p := &amp;Vertex{4, 3}</p>
</blockquote>
<p>依旧是构造一个Vertex结构，不是对底层构造的引用，但是有个好处就是，用这种方式初始化的结构体，执行其方法时</p>
<h3 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h3><p>使用指针接收者的原因有二：</p>
<p>首先，方法能够修改其接收者指向的值。</p>
<p>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p>
<p>在本例中，Scale 和 Abs 接收者的类型为 *Vertex，即便 Abs 并不需要修改其接收者。</p>
<p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。（我们会在接下来几页中明白为什么。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">	X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Scale(f float64) &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Abs() float64 &#123;</span><br><span class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	v := &amp;Vertex&#123;3, 4&#125;</span><br><span class="line">	fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs())</span><br><span class="line">	v.Scale(5)</span><br><span class="line">	fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Before scaling: &amp;&#123;X:3 Y:4&#125;, Abs: 5</span><br><span class="line">// After scaling: &amp;&#123;X:15 Y:20&#125;, Abs: 25</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口类型 是由一组方法签名定义的集合。</p>
<p>接口类型的变量可以保存任何实现了这些方法的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Abser interface &#123;</span><br><span class="line">	Abs() float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var a Abser</span><br><span class="line">	f := MyFloat(-math.Sqrt2)</span><br><span class="line">	v := Vertex&#123;3, 4&#125;</span><br><span class="line"></span><br><span class="line">	a = f  // a MyFloat 实现了 Abser</span><br><span class="line">	a = &amp;v // a *Vertex 实现了 Abser</span><br><span class="line"></span><br><span class="line">	// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span><br><span class="line">	// 所以没有实现 Abser。</span><br><span class="line">	//a = v</span><br><span class="line"></span><br><span class="line">	fmt.Println(a.Abs())</span><br><span class="line">	// 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MyFloat float64</span><br><span class="line"></span><br><span class="line">func (f MyFloat) Abs() float64 &#123;</span><br><span class="line">	if f &lt; 0 &#123;</span><br><span class="line">		return float64(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	return float64(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">	X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Abs() float64 &#123;</span><br><span class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口与隐式实现"><a href="#接口与隐式实现" class="headerlink" title="接口与隐式实现"></a>接口与隐式实现</h3><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p>
<p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p>
<p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type I interface &#123;</span><br><span class="line">	M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">	S string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span><br><span class="line">func (t T) M() &#123;</span><br><span class="line">	fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var i I = T&#123;&quot;hello&quot;&#125;</span><br><span class="line">	i.M() // hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><p>在内部，接口值可以看做包含值和具体类型的元组：</p>
<p>(value, type)<br>接口值保存了一个具体底层类型的具体值。</p>
<p>接口值调用方法时会执行其底层类型的同名方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type I interface &#123;</span><br><span class="line">	M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">	S string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *T) M() &#123;</span><br><span class="line">	fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type F float64</span><br><span class="line"></span><br><span class="line">func (f F) M() &#123;</span><br><span class="line">	fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var i I</span><br><span class="line"></span><br><span class="line">	i = &amp;T&#123;&quot;Hello&quot;&#125;</span><br><span class="line">	describe(i)</span><br><span class="line">	i.M()</span><br><span class="line"></span><br><span class="line">	i = F(math.Pi)</span><br><span class="line">	describe(i)</span><br><span class="line">	i.M()</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	/*(&amp;&#123;Hello&#125;, *main.T)</span><br><span class="line">    Hello</span><br><span class="line">    (3.141592653589793, main.F)</span><br><span class="line">    3.141592653589793*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func describe(i I) &#123;</span><br><span class="line">	fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>指定了零个方法的接口值被称为 <em>空接口：</em></p>
<p>interface{}<br>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p>
<p>空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var i interface&#123;&#125;</span><br><span class="line">	describe(i)</span><br><span class="line"></span><br><span class="line">	i = 42</span><br><span class="line">	describe(i)</span><br><span class="line"></span><br><span class="line">	i = &quot;hello&quot;</span><br><span class="line">	describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func describe(i interface&#123;&#125;) &#123;</span><br><span class="line">	fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">(&lt;nil&gt;, &lt;nil&gt;)</span><br><span class="line">(42, int)</span><br><span class="line">(hello, string)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><blockquote>
<p>一般指interface{}类型，形如：t := i.(T)</p>
</blockquote>
<blockquote>
<p>常见于 s, _ := i.(string), i, _ := i.(int)</p>
</blockquote>
<p>该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。</p>
<blockquote>
<p>若 i 并未保存 T 类型的值，该语句就会触发一个恐慌。</p>
</blockquote>
<blockquote>
<p>为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>
</blockquote>
<blockquote>
<p>t, ok := i.(T)</p>
</blockquote>
<p>若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。</p>
<blockquote>
<p>否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌。</p>
</blockquote>
<p>请注意这种语法和读取一个映射时的相同之处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var i interface&#123;&#125; = &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">	s := i.(string)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	s, ok := i.(string)</span><br><span class="line">	fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">	f, ok := i.(float64)</span><br><span class="line">	fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">	f = i.(float64) // panic</span><br><span class="line">	fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">hello</span><br><span class="line">hello true</span><br><span class="line">0 false</span><br><span class="line">panic: interface conversion: interface &#123;&#125; is string, not float64</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">	/tmp/sandbox042281205/main.go:17 +0x220</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h3><p>类型选择 是一种按顺序从几个类型断言中选择分支的结构。</p>
<p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func do(i interface&#123;&#125;) &#123;</span><br><span class="line">	switch v := i.(type) &#123;</span><br><span class="line">	case int:</span><br><span class="line">		fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2)</span><br><span class="line">	case string:</span><br><span class="line">		fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v))</span><br><span class="line">	default:</span><br><span class="line">		fmt.Printf(&quot;I don&apos;t know about type %T!\n&quot;, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	do(21)</span><br><span class="line">	do(&quot;hello&quot;)</span><br><span class="line">	do(true)</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">Twice 21 is 42</span><br><span class="line">&quot;hello&quot; is 5 bytes long</span><br><span class="line">I don&apos;t know about type bool!</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h3><p>fmt 包中定义的 Stringer 是最普遍的接口之一。</p>
<p>type Stringer interface {<br>    String() string<br>}<br>Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Person) String() string &#123;</span><br><span class="line">	return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	a := Person&#123;&quot;Arthur Dent&quot;, 42&#125;</span><br><span class="line">	z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125;</span><br><span class="line">	fmt.Println(a, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)</span><br></pre></td></tr></table></figure>

<p>去掉 func (p Person) String() string 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	a := Person&#123;&quot;Arthur Dent&quot;, 42&#125;</span><br><span class="line">	z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125;</span><br><span class="line">	fmt.Println(a, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &#123;Arthur Dent 42&#125; &#123;Zaphod Beeblebrox 9001</span><br></pre></td></tr></table></figure>

<h3 id="练习：Stringer"><a href="#练习：Stringer" class="headerlink" title="练习：Stringer"></a>练习：Stringer</h3><p>通过让 IPAddr 类型实现 fmt.Stringer 来打印点号分隔的地址。</p>
<p>例如，IPAddr{1, 2, 3, 4} 应当打印为 “1.2.3.4”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type IPAddr [4]byte</span><br><span class="line"></span><br><span class="line">// TODO: Add a &quot;String() string&quot; method to IPAddr.</span><br><span class="line"></span><br><span class="line">func (ip IPAddr) String() string &#123;</span><br><span class="line"></span><br><span class="line">	return fmt.Sprintf(&quot;%v.%v.%v.%v&quot;, ip[0], ip[1], ip[2], ip[3])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	hosts := map[string]IPAddr&#123;</span><br><span class="line">		&quot;loopback&quot;:  &#123;127, 0, 0, 1&#125;,</span><br><span class="line">		&quot;googleDNS&quot;: &#123;8, 8, 8, 8&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	for name, ip := range hosts &#123;</span><br><span class="line">		fmt.Printf(&quot;%v: %v\n&quot;, name, ip)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">没有fmt.Stringer : </span><br><span class="line">loopback: [127 0 0 1]</span><br><span class="line">googleDNS: [8 8 8 8]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">加上 fmt.Stringer:</span><br><span class="line">loopback: 127.0.0.1</span><br><span class="line">googleDNS: 8.8.8.8</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="练习：错误"><a href="#练习：错误" class="headerlink" title="练习：错误"></a>练习：错误</h3><p>从之前的练习中复制 Sqrt 函数，修改它使其返回 error 值。</p>
<p>Sqrt 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。</p>
<p>创建一个新的类型</p>
<p>type ErrNegativeSqrt float64<br>并为其实现</p>
<p>func (e ErrNegativeSqrt) Error() string<br>方法使其拥有 error 值，通过 ErrNegativeSqrt(-2).Error() 调用该方法应返回 “cannot Sqrt negative number: -2”。</p>
<p><em>注意：</em> 在 Error 方法内调用 fmt.Sprint(e) 会让程序陷入死循环。可以通过先转换 e 来避免这个问题：fmt.Sprint(float64(e))。这是为什么呢？</p>
<p>修改 Sqrt 函数，使其接受一个负数时，返回 ErrNegativeSqrt 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Sqrt(x float64) (float64, error) &#123;</span><br><span class="line">	if x &lt; 0 &#123;</span><br><span class="line">		return x, ErrNegativeSqrt(x)</span><br><span class="line">	&#125;</span><br><span class="line">	return math.Sqrt(x), nil</span><br><span class="line">&#125;</span><br><span class="line">type ErrNegativeSqrt float64</span><br><span class="line"></span><br><span class="line">func (e ErrNegativeSqrt) Error() string &#123;   </span><br><span class="line">	return fmt.Sprintf(&quot;cannot Sqrt negative number: %v&quot;, float64(e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(Sqrt(2))</span><br><span class="line">	fmt.Println(Sqrt(-2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">1.4142135623730951 &lt;nil&gt;</span><br><span class="line">-2 cannot Sqrt negative number: -2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>io 包指定了 io.Reader 接口，它表示从数据流的末尾进行读取。</p>
<p>Go 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。</p>
<p>io.Reader 接口有一个 Read 方法：</p>
<p>func (T) Read(b []byte) (n int, err error)<br>Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。</p>
<p>示例代码创建了一个 strings.Reader 并以每次 8 字节的速度读取它的输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r := strings.NewReader(&quot;Hello, Reader!&quot;)</span><br><span class="line"></span><br><span class="line">	b := make([]byte, 8)</span><br><span class="line">	for &#123;</span><br><span class="line">		n, err := r.Read(b)</span><br><span class="line">		fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)</span><br><span class="line">		fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]</span><br><span class="line">b[:n] = &quot;Hello, R&quot;</span><br><span class="line">n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]</span><br><span class="line">b[:n] = &quot;eader!&quot;</span><br><span class="line">n = 0 err = EOF b = [101 97 100 101 114 33 32 82]</span><br><span class="line">b[:n] = &quot;&quot;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="练习：Reader"><a href="#练习：Reader" class="headerlink" title="练习：Reader"></a>练习：Reader</h3><p>实现一个 Reader 类型，它产生一个 ASCII 字符 ‘A’ 的无限流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;golang.org/x/tour/reader&quot;</span><br><span class="line"></span><br><span class="line">type MyReader struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// TODO: Add a Read([]byte) (int, error) method to MyReader.</span><br><span class="line"></span><br><span class="line">func (mr MyReader) Read(b []byte) (int, error)&#123;</span><br><span class="line">    b[0] = &apos;A&apos;</span><br><span class="line">    return 1, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	reader.Validate(MyReader&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// OK!</span><br></pre></td></tr></table></figure>

<h3 id="练习：rot13Reader"><a href="#练习：rot13Reader" class="headerlink" title="练习：rot13Reader"></a>练习：rot13Reader</h3><p>有种常见的模式是一个 io.Reader 包装另一个 io.Reader，然后通过某种方式修改其数据流。</p>
<p>例如，gzip.NewReader 函数接受一个 io.Reader（已压缩的数据流）并返回一个同样实现了 io.Reader 的 *gzip.Reader（解压后的数据流）。</p>
<p>编写一个实现了 io.Reader 并从另一个 io.Reader 中读取数据的 rot13Reader，通过应用 rot13 代换密码对数据流进行修改。</p>
<p>rot13Reader 类型已经提供。实现 Read 方法以满足 io.Reader。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type rot13Reader struct &#123;</span><br><span class="line">	r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func rot13(out byte) byte &#123;</span><br><span class="line">	switch &#123;</span><br><span class="line">	case out &gt;= &apos;A&apos; &amp;&amp; out &lt;= &apos;M&apos; || out &gt;= &apos;a&apos; &amp;&amp; out &lt;= &apos;m&apos;:</span><br><span class="line">		out += 13</span><br><span class="line">	case out &gt;= &apos;N&apos; &amp;&amp; out &lt;= &apos;Z&apos; || out &gt;= &apos;a&apos; &amp;&amp; out &lt;= &apos;z&apos;:</span><br><span class="line">		out -= 13</span><br><span class="line">	&#125;</span><br><span class="line">	return out</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fz rot13Reader) Read(b []byte) (int, error) &#123;</span><br><span class="line">	n, e := fz.r.Read(b)</span><br><span class="line">	for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">		b[i] = rot13(b[i])</span><br><span class="line">	&#125;</span><br><span class="line">	return n, e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s := strings.NewReader(&quot;Lbh penpxrq gur pbqr!&quot;)</span><br><span class="line">	r := rot13Reader&#123;s&#125;</span><br><span class="line">	io.Copy(os.Stdout, &amp;r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// You cracked the code!</span><br></pre></td></tr></table></figure>

<h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><p>image 包定义了 Image 接口：</p>
<p>package image</p>
<p>type Image interface {<br>    ColorModel() color.Model<br>    Bounds() Rectangle<br>    At(x, y int) color.Color<br>}<br><em>注意：</em> Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明。</p>
<p>（请参阅文档了解全部信息。）</p>
<p>color.Color 和 color.Model 类型也是接口，但是通常因为直接使用预定义的实现 image.RGBA 和 image.RGBAModel 而被忽视了。这些接口和类型由 image/color 包定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;image&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	m := image.NewRGBA(image.Rect(0, 0, 100, 100))</span><br><span class="line">	fmt.Println(m.Bounds())</span><br><span class="line">	fmt.Println(m.At(0, 0).RGBA())</span><br><span class="line">&#125;</span><br><span class="line">// (0,0)-(100,100)</span><br><span class="line">// 0 0 0 0</span><br></pre></td></tr></table></figure>

<h3 id="练习：图像"><a href="#练习：图像" class="headerlink" title="练习：图像"></a>练习：图像</h3><p>还记得之前编写的图片生成器吗？我们再来编写另外一个，不过这次它将会返回一个 image.Image 的实现而非一个数据切片。</p>
<p>定义你自己的 Image 类型，实现必要的方法并调用 pic.ShowImage。</p>
<p>Bounds 应当返回一个 image.Rectangle ，例如 image.Rect(0, 0, w, h)。</p>
<p>ColorModel 应当返回 color.RGBAModel。</p>
<p>At 应当返回一个颜色。上一个图片生成器的值 v 对应于此次的 color.RGBA{v, v, 255, 255}。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;golang.org/x/tour/pic&quot;</span><br><span class="line">    &quot;image/color&quot;</span><br><span class="line">    &quot;image&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Image struct&#123;&#125;  //新建一个Image结构体</span><br><span class="line"></span><br><span class="line">func (i Image) ColorModel() color.Model&#123;  //实现Image包中颜色模式的方法</span><br><span class="line">    return color.RGBAModel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (i Image) Bounds() image.Rectangle&#123;  //实现Image包中生成图片边界的方法</span><br><span class="line">    return image.Rect(0,0,200,200)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (i Image) At(x,y int) color.Color&#123;  //实现Image包中生成图像某个点的方法</span><br><span class="line">    return color.RGBA&#123;uint8(x),uint8(y),uint8(255),uint8(255)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m := Image&#123;&#125;</span><br><span class="line">    pic.ShowImage(m)  //调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Go/" rel="tag"># Go</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/11/go/Go学习笔记一/" rel="next" title="Go学习笔记一">
                  <i class="fa fa-chevron-left"></i> Go学习笔记一
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/09/11/go/Go学习笔记三---高级/" rel="prev" title="Go学习笔记三---高级">
                  Go学习笔记三---高级 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法和接口"><span class="nav-number">1.</span> <span class="nav-text">方法和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">1.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法即函数"><span class="nav-number">1.2.</span> <span class="nav-text">方法即函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非结构体类型"><span class="nav-number">1.3.</span> <span class="nav-text">非结构体类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针接收者"><span class="nav-number">1.4.</span> <span class="nav-text">指针接收者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法与指针重定向"><span class="nav-number">1.5.</span> <span class="nav-text">方法与指针重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择值或指针作为接收者"><span class="nav-number">1.6.</span> <span class="nav-text">选择值或指针作为接收者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">1.7.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口与隐式实现"><span class="nav-number">1.8.</span> <span class="nav-text">接口与隐式实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口值"><span class="nav-number">1.9.</span> <span class="nav-text">接口值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空接口"><span class="nav-number">1.10.</span> <span class="nav-text">空接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型断言"><span class="nav-number">1.11.</span> <span class="nav-text">类型断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型选择"><span class="nav-number">1.12.</span> <span class="nav-text">类型选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stringer"><span class="nav-number">1.13.</span> <span class="nav-text">Stringer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：Stringer"><span class="nav-number">1.14.</span> <span class="nav-text">练习：Stringer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：错误"><span class="nav-number">1.15.</span> <span class="nav-text">练习：错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reader"><span class="nav-number">1.16.</span> <span class="nav-text">Reader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：Reader"><span class="nav-number">1.17.</span> <span class="nav-text">练习：Reader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：rot13Reader"><span class="nav-number">1.18.</span> <span class="nav-text">练习：rot13Reader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图像"><span class="nav-number">1.19.</span> <span class="nav-text">图像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：图像"><span class="nav-number">1.20.</span> <span class="nav-text">练习：图像</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="haidaoge">
  <p class="site-author-name" itemprop="name">haidaoge</p>
  <div class="site-description" itemprop="description">haidaoge 的日志</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">haidaoge</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script><script src="/js/bookmark.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  

</body>
</html>
